package main

import (
	"context"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/cyberspacesec/go-port-rocket/pkg/scanner"
)

// 定义漏洞数据结构
type Vulnerability struct {
	Name        string  // 漏洞名称
	Description string  // 描述
	Severity    string  // 严重程度
	CVE         string  // CVE编号
	CVSS        float64 // CVSS评分
	Detected    bool    // 是否检测到
	Evidence    string  // 证据
}

// 定义常见服务的漏洞列表
var knownVulnerabilities = map[string][]Vulnerability{
	"ssh": {
		{
			Name:        "SSH弱加密算法",
			Description: "SSH服务配置使用了弱加密算法，如DES或3DES",
			Severity:    "中",
			CVE:         "CVE-2008-5161",
			CVSS:        4.3,
		},
		{
			Name:        "OpenSSH < 7.4版本",
			Description: "低版本的OpenSSH存在多个漏洞",
			Severity:    "高",
			CVE:         "CVE-2016-8858",
			CVSS:        7.5,
		},
	},
	"http": {
		{
			Name:        "Web服务器信息泄露",
			Description: "HTTP头信息泄露了服务器详细版本信息",
			Severity:    "低",
			CVE:         "无",
			CVSS:        2.6,
		},
		{
			Name:        "TLS/SSL弱加密算法",
			Description: "HTTPS服务配置使用了弱加密算法或不安全的TLS版本",
			Severity:    "中",
			CVE:         "CVE-2015-0204",
			CVSS:        4.3,
		},
		{
			Name:        "Heartbleed漏洞",
			Description: "OpenSSL中的Heartbleed漏洞(CVE-2014-0160)允许远程攻击者获取内存内容",
			Severity:    "高",
			CVE:         "CVE-2014-0160",
			CVSS:        7.5,
		},
	},
	"ftp": {
		{
			Name:        "匿名FTP访问",
			Description: "FTP服务器允许匿名访问",
			Severity:    "中",
			CVE:         "无",
			CVSS:        5.0,
		},
		{
			Name:        "明文FTP传输",
			Description: "FTP使用明文传输凭据和数据",
			Severity:    "高",
			CVE:         "无",
			CVSS:        7.5,
		},
	},
	"telnet": {
		{
			Name:        "Telnet明文传输",
			Description: "Telnet服务使用明文传输数据，容易被窃听",
			Severity:    "高",
			CVE:         "无",
			CVSS:        8.0,
		},
	},
	"smtp": {
		{
			Name:        "SMTP VRFY命令启用",
			Description: "SMTP服务器允许VRFY命令，可用于枚举用户",
			Severity:    "低",
			CVE:         "无",
			CVSS:        3.5,
		},
		{
			Name:        "开放邮件中继",
			Description: "邮件服务器配置不当，可能允许未经认证的邮件中继",
			Severity:    "高",
			CVE:         "无",
			CVSS:        8.5,
		},
	},
	"dns": {
		{
			Name:        "DNS区域传送",
			Description: "DNS服务器允许区域传送，可能泄露所有域名信息",
			Severity:    "中",
			CVE:         "无",
			CVSS:        5.0,
		},
	},
}

func main() {
	// 创建一个超时上下文
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// 添加一个goroutine监控超时
	go func() {
		<-ctx.Done()
		if ctx.Err() == context.DeadlineExceeded {
			fmt.Println("\n[!] 扫描超时 - 已达到最大运行时间 (30秒)")
			os.Exit(0)
		}
	}()

	// 解析命令行参数
	fastMode := false
	if len(os.Args) > 1 && (os.Args[1] == "--fast" || os.Args[1] == "-f") {
		fastMode = true
	}

	target := "scanme.nmap.org"
	fmt.Println("====================================")
	fmt.Println("       漏洞扫描示例")
	fmt.Println("====================================")
	fmt.Printf("目标: %s\n", target)
	if fastMode {
		fmt.Println("模式: 快速模式 (仅扫描关键端口)")
	} else {
		fmt.Println("模式: 完整模式 (提示: 使用 --fast 参数可以加快扫描速度)")
	}
	fmt.Println()

	// 定义常见服务对应的端口
	servicesAndPorts := map[string]string{
		"ftp":      "21",
		"ssh":      "22",
		"telnet":   "23",
		"smtp":     "25",
		"dns":      "53",
		"http":     "80,443",
		"pop3":     "110",
		"ntp":      "123",
		"imap":     "143",
		"snmp":     "161",
		"ldap":     "389",
		"https":    "443",
		"smb":      "445",
		"oracle":   "1521",
		"mssql":    "1433",
		"mysql":    "3306",
		"rdp":      "3389",
		"postgres": "5432",
		"vnc":      "5900",
		"redis":    "6379",
		"mongo":    "27017",
	}

	// 如果是快速模式，只扫描主要的几个端口
	if fastMode {
		// 只保留最常见的几个服务
		reducedServices := map[string]string{
			"ssh":   "22",
			"http":  "80",
			"https": "443",
		}
		servicesAndPorts = reducedServices
	}

	// 构建端口列表进行扫描
	var ports []string
	for _, portStr := range servicesAndPorts {
		ports = append(ports, portStr)
	}
	portsToScan := strings.Join(ports, ",")

	fmt.Printf("正在进行端口和服务扫描...\n")
	fmt.Printf("扫描端口: %s\n\n", portsToScan)

	// 创建扫描配置
	scanOptions := &scanner.ScanOptions{
		Target:   target,
		Ports:    portsToScan,
		ScanType: scanner.ScanTypeTCP,
		Timeout:  time.Second * 2,
		Workers:  50,
	}

	// 执行扫描
	scanStart := time.Now()
	scanResults, err := scanner.ExecuteScan(scanOptions)
	scanDuration := time.Since(scanStart)

	if err != nil {
		fmt.Printf("扫描错误: %v\n", err)
		return
	}

	// 处理扫描结果
	openPorts := []scanner.ScanResult{}
	for _, result := range scanResults {
		if result.State == scanner.PortStateOpen {
			openPorts = append(openPorts, result)
		}
	}

	fmt.Printf("发现 %d 个开放端口，用时 %.2f 秒\n\n", len(openPorts), scanDuration.Seconds())

	// 分析服务版本并检测潜在漏洞
	fmt.Println("正在分析服务版本并检测潜在漏洞...")
	detectVulnerabilities(openPorts)

	// 进行额外的TCP/UDP安全扫描
	fmt.Println("\n正在进行额外的安全检查...")
	performSecurityChecks(target)

	fmt.Println("\n扫描完成！")
}

// 检测发现的服务中的已知漏洞
func detectVulnerabilities(results []scanner.ScanResult) {
	// 计数器
	severityCounts := map[string]int{
		"低": 0,
		"中": 0,
		"高": 0,
	}

	// 创建检测到的漏洞列表
	var detectedVulns []Vulnerability

	for _, result := range results {
		if result.State != scanner.PortStateOpen {
			continue
		}

		// 尝试通过服务名称匹配
		var serviceType string
		if result.Service != nil && result.Service.Name != "" {
			serviceType = strings.ToLower(result.Service.Name)
		} else {
			// 尝试通过常见端口猜测服务类型
			serviceType = guessServiceByPort(result.Port)
		}

		if serviceType == "" {
			continue
		}

		fmt.Printf("\n[端口 %d/tcp] 检测服务: %s\n",
			result.Port, formatServiceInfo(result))

		// 查找此服务可能存在的漏洞
		vulns, found := knownVulnerabilities[serviceType]
		if !found {
			fmt.Println("  └─ 未发现针对此服务的已知漏洞定义")
			continue
		}

		// 分析每个可能的漏洞
		vulnFound := false
		for i := range vulns {
			// 深拷贝，避免修改原始数据
			vuln := vulns[i]

			// 基于服务版本和Banner信息检测漏洞
			isVulnerable, evidence := checkVulnerability(serviceType, &result, &vuln)

			if isVulnerable {
				vulnFound = true
				severityCounts[vuln.Severity]++

				vuln.Detected = true
				vuln.Evidence = evidence
				detectedVulns = append(detectedVulns, vuln)

				// 打印漏洞信息
				severityColor := getSeverityColor(vuln.Severity)
				fmt.Printf("  %s [%s] %s (CVSS: %.1f)\n",
					severityColor, vuln.Severity, vuln.Name, vuln.CVSS)
				fmt.Printf("    └─ %s\n", vuln.Description)
				if vuln.CVE != "无" && vuln.CVE != "" {
					fmt.Printf("    └─ CVE: %s\n", vuln.CVE)
				}
				fmt.Printf("    └─ 证据: %s\n", evidence)
			}
		}

		if !vulnFound {
			fmt.Println("  └─ 未检测到已知漏洞")
		}
	}

	// 打印漏洞统计信息
	fmt.Println("\n漏洞统计:")
	fmt.Printf("总计发现 %d 个潜在漏洞:\n", len(detectedVulns))
	fmt.Printf("  - 高危: %d\n", severityCounts["高"])
	fmt.Printf("  - 中危: %d\n", severityCounts["中"])
	fmt.Printf("  - 低危: %d\n", severityCounts["低"])
}

// 格式化服务信息显示
func formatServiceInfo(result scanner.ScanResult) string {
	if result.Service == nil {
		return "未知服务"
	}

	info := result.Service.Name
	if result.Service.Version != "" {
		info += " " + result.Service.Version
	}

	if result.Banner != "" {
		shortBanner := result.Banner
		if len(shortBanner) > 50 {
			shortBanner = shortBanner[:47] + "..."
		}
		info += " [" + shortBanner + "]"
	}

	return info
}

// 根据端口号猜测服务类型
func guessServiceByPort(port int) string {
	switch port {
	case 21:
		return "ftp"
	case 22:
		return "ssh"
	case 23:
		return "telnet"
	case 25, 465, 587:
		return "smtp"
	case 53:
		return "dns"
	case 80, 8080:
		return "http"
	case 443, 8443:
		return "http" // 使用http相同的漏洞库
	case 110, 995:
		return "pop3"
	case 143, 993:
		return "imap"
	case 161:
		return "snmp"
	default:
		return ""
	}
}

// 检查特定服务是否存在特定漏洞
func checkVulnerability(serviceType string, result *scanner.ScanResult, vuln *Vulnerability) (bool, string) {
	banner := result.Banner
	var version string

	if result.Service != nil {
		version = result.Service.Version
	}

	switch serviceType {
	case "ssh":
		// 检查SSH版本
		if vuln.Name == "OpenSSH < 7.4版本" && strings.Contains(version, "OpenSSH") {
			parts := strings.Split(version, " ")
			if len(parts) > 1 {
				versionStr := parts[1]
				if strings.HasPrefix(versionStr, "1.") ||
					strings.HasPrefix(versionStr, "2.") ||
					strings.HasPrefix(versionStr, "3.") ||
					strings.HasPrefix(versionStr, "4.") ||
					strings.HasPrefix(versionStr, "5.") ||
					strings.HasPrefix(versionStr, "6.") ||
					(strings.HasPrefix(versionStr, "7.") && versionStr < "7.4") {
					return true, fmt.Sprintf("检测到低版本SSH: %s", version)
				}
			}
		}

		// 检查SSH弱加密
		if vuln.Name == "SSH弱加密算法" && strings.Contains(banner, "3des") {
			return true, "服务器支持弱加密算法: 3DES"
		}

	case "http":
		// 检查信息泄露
		if vuln.Name == "Web服务器信息泄露" &&
			(strings.Contains(banner, "Apache/") ||
				strings.Contains(banner, "nginx/") ||
				strings.Contains(banner, "Microsoft-IIS/")) {
			return true, fmt.Sprintf("服务器头信息泄露版本: %s", banner)
		}

		// 简化版的Heartbleed检测
		if vuln.Name == "Heartbleed漏洞" &&
			result.Service != nil &&
			strings.Contains(version, "OpenSSL 1.0.1") {
			versionChar := version[len("OpenSSL 1.0.1")]
			if versionChar >= 'a' && versionChar <= 'f' {
				return true, fmt.Sprintf("检测到易受Heartbleed影响的OpenSSL版本: %s", version)
			}
		}

	case "ftp":
		// 检查匿名FTP访问
		if vuln.Name == "匿名FTP访问" &&
			(strings.Contains(banner, "anonymous") ||
				strings.Contains(banner, "login anonymous")) {
			return true, "FTP服务器标志表明可能支持匿名访问"
		}

		// FTP明文传输总是存在的问题
		if vuln.Name == "明文FTP传输" {
			return true, "标准FTP协议使用明文传输数据和凭据"
		}

	case "telnet":
		// Telnet明文传输总是存在的问题
		if vuln.Name == "Telnet明文传输" {
			return true, "检测到Telnet服务，默认使用明文传输数据"
		}

	case "smtp":
		// 简单检测是否可能存在开放中继
		if vuln.Name == "开放邮件中继" &&
			!strings.Contains(banner, "Authentication") {
			return true, "SMTP Banner未明确指示需要认证，可能存在中继风险"
		}

		// 检测VRFY命令是否启用
		if vuln.Name == "SMTP VRFY命令启用" {
			// 实际中需要尝试VRFY命令，这里仅示例
			return true, "SMTP服务通常默认启用VRFY命令"
		}
	}

	// 未检测到漏洞
	return false, ""
}

// 额外的安全性检查
func performSecurityChecks(target string) {
	var wg sync.WaitGroup

	// 常见安全检查列表
	checks := []struct {
		name string
		fn   func(string, *sync.WaitGroup)
	}{
		{
			name: "开放端口范围检查",
			fn:   checkPortRange,
		},
		{
			name: "弱SSL配置检查",
			fn:   checkWeakSSL,
		},
		{
			name: "DNS配置检查",
			fn:   checkDNSConfig,
		},
	}

	// 执行所有安全检查
	for _, check := range checks {
		wg.Add(1)
		go check.fn(target, &wg)
	}

	// 等待所有检查完成
	wg.Wait()
}

// 检查是否存在过多开放端口
func checkPortRange(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] 执行开放端口范围检查...\n")

	// 检查范围端口
	highPorts := "32768-33000"

	scanOptions := &scanner.ScanOptions{
		Target:   target,
		Ports:    highPorts,
		ScanType: scanner.ScanTypeTCP,
		Timeout:  time.Second * 1,
		Workers:  100,
	}

	results, err := scanner.ExecuteScan(scanOptions)
	if err != nil {
		fmt.Printf("    └─ 检查失败: %v\n", err)
		return
	}

	openCount := 0
	for _, result := range results {
		if result.State == scanner.PortStateOpen {
			openCount++
		}
	}

	if openCount > 5 {
		fmt.Printf("    └─ [⚠️ 警告] 发现大量高端口开放 (%d 个)\n", openCount)
		fmt.Printf("    └─ 可能表明存在未授权的服务或后门\n")
	} else {
		fmt.Printf("    └─ 未发现异常的高端口开放情况\n")
	}
}

// 检查弱SSL配置
func checkWeakSSL(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] 执行SSL/TLS配置检查...\n")

	// 连接到目标的HTTPS端口
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:443", target), time.Second*5)
	if err != nil {
		fmt.Printf("    └─ 未发现HTTPS服务或连接失败: %v\n", err)
		return
	}
	defer conn.Close()

	// 实际项目中需要对SSL配置进行深入检测
	// 这里仅做示例
	fmt.Printf("    └─ HTTPS服务可访问，但需要专门的SSL测试工具进行深入分析\n")
	fmt.Printf("    └─ 建议使用专业工具如SSLLabs, testssl.sh等进行检测\n")
}

// 检查DNS配置
func checkDNSConfig(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] 执行DNS配置检查...\n")

	// 检查是否存在区域传送漏洞
	// 实际实现需要发送DNS AXFR请求

	// 解析目标主机
	ips, err := net.LookupIP(target)
	if err != nil {
		fmt.Printf("    └─ 无法解析目标: %v\n", err)
		return
	}

	fmt.Printf("    └─ 目标解析为: %v\n", ips)
	fmt.Printf("    └─ 未执行完整DNS安全检测，建议使用专业DNS安全工具\n")
}

// 返回与严重程度对应的颜色代码
func getSeverityColor(severity string) string {
	switch severity {
	case "高":
		return "🔴"
	case "中":
		return "🟠"
	case "低":
		return "🟡"
	default:
		return "⚪"
	}
}
