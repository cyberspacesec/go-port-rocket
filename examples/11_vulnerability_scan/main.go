package main

import (
	"context"
	"fmt"
	"net"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/cyberspacesec/go-port-rocket/pkg/scanner"
)

// å®šä¹‰æ¼æ´æ•°æ®ç»“æ„
type Vulnerability struct {
	Name        string  // æ¼æ´åç§°
	Description string  // æè¿°
	Severity    string  // ä¸¥é‡ç¨‹åº¦
	CVE         string  // CVEç¼–å·
	CVSS        float64 // CVSSè¯„åˆ†
	Detected    bool    // æ˜¯å¦æ£€æµ‹åˆ°
	Evidence    string  // è¯æ®
}

// å®šä¹‰å¸¸è§æœåŠ¡çš„æ¼æ´åˆ—è¡¨
var knownVulnerabilities = map[string][]Vulnerability{
	"ssh": {
		{
			Name:        "SSHå¼±åŠ å¯†ç®—æ³•",
			Description: "SSHæœåŠ¡é…ç½®ä½¿ç”¨äº†å¼±åŠ å¯†ç®—æ³•ï¼Œå¦‚DESæˆ–3DES",
			Severity:    "ä¸­",
			CVE:         "CVE-2008-5161",
			CVSS:        4.3,
		},
		{
			Name:        "OpenSSH < 7.4ç‰ˆæœ¬",
			Description: "ä½ç‰ˆæœ¬çš„OpenSSHå­˜åœ¨å¤šä¸ªæ¼æ´",
			Severity:    "é«˜",
			CVE:         "CVE-2016-8858",
			CVSS:        7.5,
		},
	},
	"http": {
		{
			Name:        "WebæœåŠ¡å™¨ä¿¡æ¯æ³„éœ²",
			Description: "HTTPå¤´ä¿¡æ¯æ³„éœ²äº†æœåŠ¡å™¨è¯¦ç»†ç‰ˆæœ¬ä¿¡æ¯",
			Severity:    "ä½",
			CVE:         "æ— ",
			CVSS:        2.6,
		},
		{
			Name:        "TLS/SSLå¼±åŠ å¯†ç®—æ³•",
			Description: "HTTPSæœåŠ¡é…ç½®ä½¿ç”¨äº†å¼±åŠ å¯†ç®—æ³•æˆ–ä¸å®‰å…¨çš„TLSç‰ˆæœ¬",
			Severity:    "ä¸­",
			CVE:         "CVE-2015-0204",
			CVSS:        4.3,
		},
		{
			Name:        "Heartbleedæ¼æ´",
			Description: "OpenSSLä¸­çš„Heartbleedæ¼æ´(CVE-2014-0160)å…è®¸è¿œç¨‹æ”»å‡»è€…è·å–å†…å­˜å†…å®¹",
			Severity:    "é«˜",
			CVE:         "CVE-2014-0160",
			CVSS:        7.5,
		},
	},
	"ftp": {
		{
			Name:        "åŒ¿åFTPè®¿é—®",
			Description: "FTPæœåŠ¡å™¨å…è®¸åŒ¿åè®¿é—®",
			Severity:    "ä¸­",
			CVE:         "æ— ",
			CVSS:        5.0,
		},
		{
			Name:        "æ˜æ–‡FTPä¼ è¾“",
			Description: "FTPä½¿ç”¨æ˜æ–‡ä¼ è¾“å‡­æ®å’Œæ•°æ®",
			Severity:    "é«˜",
			CVE:         "æ— ",
			CVSS:        7.5,
		},
	},
	"telnet": {
		{
			Name:        "Telnetæ˜æ–‡ä¼ è¾“",
			Description: "TelnetæœåŠ¡ä½¿ç”¨æ˜æ–‡ä¼ è¾“æ•°æ®ï¼Œå®¹æ˜“è¢«çªƒå¬",
			Severity:    "é«˜",
			CVE:         "æ— ",
			CVSS:        8.0,
		},
	},
	"smtp": {
		{
			Name:        "SMTP VRFYå‘½ä»¤å¯ç”¨",
			Description: "SMTPæœåŠ¡å™¨å…è®¸VRFYå‘½ä»¤ï¼Œå¯ç”¨äºæšä¸¾ç”¨æˆ·",
			Severity:    "ä½",
			CVE:         "æ— ",
			CVSS:        3.5,
		},
		{
			Name:        "å¼€æ”¾é‚®ä»¶ä¸­ç»§",
			Description: "é‚®ä»¶æœåŠ¡å™¨é…ç½®ä¸å½“ï¼Œå¯èƒ½å…è®¸æœªç»è®¤è¯çš„é‚®ä»¶ä¸­ç»§",
			Severity:    "é«˜",
			CVE:         "æ— ",
			CVSS:        8.5,
		},
	},
	"dns": {
		{
			Name:        "DNSåŒºåŸŸä¼ é€",
			Description: "DNSæœåŠ¡å™¨å…è®¸åŒºåŸŸä¼ é€ï¼Œå¯èƒ½æ³„éœ²æ‰€æœ‰åŸŸåä¿¡æ¯",
			Severity:    "ä¸­",
			CVE:         "æ— ",
			CVSS:        5.0,
		},
	},
}

func main() {
	// åˆ›å»ºä¸€ä¸ªè¶…æ—¶ä¸Šä¸‹æ–‡
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	defer cancel()

	// æ·»åŠ ä¸€ä¸ªgoroutineç›‘æ§è¶…æ—¶
	go func() {
		<-ctx.Done()
		if ctx.Err() == context.DeadlineExceeded {
			fmt.Println("\n[!] æ‰«æè¶…æ—¶ - å·²è¾¾åˆ°æœ€å¤§è¿è¡Œæ—¶é—´ (30ç§’)")
			os.Exit(0)
		}
	}()

	// è§£æå‘½ä»¤è¡Œå‚æ•°
	fastMode := false
	if len(os.Args) > 1 && (os.Args[1] == "--fast" || os.Args[1] == "-f") {
		fastMode = true
	}

	target := "scanme.nmap.org"
	fmt.Println("====================================")
	fmt.Println("       æ¼æ´æ‰«æç¤ºä¾‹")
	fmt.Println("====================================")
	fmt.Printf("ç›®æ ‡: %s\n", target)
	if fastMode {
		fmt.Println("æ¨¡å¼: å¿«é€Ÿæ¨¡å¼ (ä»…æ‰«æå…³é”®ç«¯å£)")
	} else {
		fmt.Println("æ¨¡å¼: å®Œæ•´æ¨¡å¼ (æç¤º: ä½¿ç”¨ --fast å‚æ•°å¯ä»¥åŠ å¿«æ‰«æé€Ÿåº¦)")
	}
	fmt.Println()

	// å®šä¹‰å¸¸è§æœåŠ¡å¯¹åº”çš„ç«¯å£
	servicesAndPorts := map[string]string{
		"ftp":      "21",
		"ssh":      "22",
		"telnet":   "23",
		"smtp":     "25",
		"dns":      "53",
		"http":     "80,443",
		"pop3":     "110",
		"ntp":      "123",
		"imap":     "143",
		"snmp":     "161",
		"ldap":     "389",
		"https":    "443",
		"smb":      "445",
		"oracle":   "1521",
		"mssql":    "1433",
		"mysql":    "3306",
		"rdp":      "3389",
		"postgres": "5432",
		"vnc":      "5900",
		"redis":    "6379",
		"mongo":    "27017",
	}

	// å¦‚æœæ˜¯å¿«é€Ÿæ¨¡å¼ï¼Œåªæ‰«æä¸»è¦çš„å‡ ä¸ªç«¯å£
	if fastMode {
		// åªä¿ç•™æœ€å¸¸è§çš„å‡ ä¸ªæœåŠ¡
		reducedServices := map[string]string{
			"ssh":   "22",
			"http":  "80",
			"https": "443",
		}
		servicesAndPorts = reducedServices
	}

	// æ„å»ºç«¯å£åˆ—è¡¨è¿›è¡Œæ‰«æ
	var ports []string
	for _, portStr := range servicesAndPorts {
		ports = append(ports, portStr)
	}
	portsToScan := strings.Join(ports, ",")

	fmt.Printf("æ­£åœ¨è¿›è¡Œç«¯å£å’ŒæœåŠ¡æ‰«æ...\n")
	fmt.Printf("æ‰«æç«¯å£: %s\n\n", portsToScan)

	// åˆ›å»ºæ‰«æé…ç½®
	scanOptions := &scanner.ScanOptions{
		Target:   target,
		Ports:    portsToScan,
		ScanType: scanner.ScanTypeTCP,
		Timeout:  time.Second * 2,
		Workers:  50,
	}

	// æ‰§è¡Œæ‰«æ
	scanStart := time.Now()
	scanResults, err := scanner.ExecuteScan(scanOptions)
	scanDuration := time.Since(scanStart)

	if err != nil {
		fmt.Printf("æ‰«æé”™è¯¯: %v\n", err)
		return
	}

	// å¤„ç†æ‰«æç»“æœ
	openPorts := []scanner.ScanResult{}
	for _, result := range scanResults {
		if result.State == scanner.PortStateOpen {
			openPorts = append(openPorts, result)
		}
	}

	fmt.Printf("å‘ç° %d ä¸ªå¼€æ”¾ç«¯å£ï¼Œç”¨æ—¶ %.2f ç§’\n\n", len(openPorts), scanDuration.Seconds())

	// åˆ†ææœåŠ¡ç‰ˆæœ¬å¹¶æ£€æµ‹æ½œåœ¨æ¼æ´
	fmt.Println("æ­£åœ¨åˆ†ææœåŠ¡ç‰ˆæœ¬å¹¶æ£€æµ‹æ½œåœ¨æ¼æ´...")
	detectVulnerabilities(openPorts)

	// è¿›è¡Œé¢å¤–çš„TCP/UDPå®‰å…¨æ‰«æ
	fmt.Println("\næ­£åœ¨è¿›è¡Œé¢å¤–çš„å®‰å…¨æ£€æŸ¥...")
	performSecurityChecks(target)

	fmt.Println("\næ‰«æå®Œæˆï¼")
}

// æ£€æµ‹å‘ç°çš„æœåŠ¡ä¸­çš„å·²çŸ¥æ¼æ´
func detectVulnerabilities(results []scanner.ScanResult) {
	// è®¡æ•°å™¨
	severityCounts := map[string]int{
		"ä½": 0,
		"ä¸­": 0,
		"é«˜": 0,
	}

	// åˆ›å»ºæ£€æµ‹åˆ°çš„æ¼æ´åˆ—è¡¨
	var detectedVulns []Vulnerability

	for _, result := range results {
		if result.State != scanner.PortStateOpen {
			continue
		}

		// å°è¯•é€šè¿‡æœåŠ¡åç§°åŒ¹é…
		var serviceType string
		if result.Service != nil && result.Service.Name != "" {
			serviceType = strings.ToLower(result.Service.Name)
		} else {
			// å°è¯•é€šè¿‡å¸¸è§ç«¯å£çŒœæµ‹æœåŠ¡ç±»å‹
			serviceType = guessServiceByPort(result.Port)
		}

		if serviceType == "" {
			continue
		}

		fmt.Printf("\n[ç«¯å£ %d/tcp] æ£€æµ‹æœåŠ¡: %s\n",
			result.Port, formatServiceInfo(result))

		// æŸ¥æ‰¾æ­¤æœåŠ¡å¯èƒ½å­˜åœ¨çš„æ¼æ´
		vulns, found := knownVulnerabilities[serviceType]
		if !found {
			fmt.Println("  â””â”€ æœªå‘ç°é’ˆå¯¹æ­¤æœåŠ¡çš„å·²çŸ¥æ¼æ´å®šä¹‰")
			continue
		}

		// åˆ†ææ¯ä¸ªå¯èƒ½çš„æ¼æ´
		vulnFound := false
		for i := range vulns {
			// æ·±æ‹·è´ï¼Œé¿å…ä¿®æ”¹åŸå§‹æ•°æ®
			vuln := vulns[i]

			// åŸºäºæœåŠ¡ç‰ˆæœ¬å’ŒBannerä¿¡æ¯æ£€æµ‹æ¼æ´
			isVulnerable, evidence := checkVulnerability(serviceType, &result, &vuln)

			if isVulnerable {
				vulnFound = true
				severityCounts[vuln.Severity]++

				vuln.Detected = true
				vuln.Evidence = evidence
				detectedVulns = append(detectedVulns, vuln)

				// æ‰“å°æ¼æ´ä¿¡æ¯
				severityColor := getSeverityColor(vuln.Severity)
				fmt.Printf("  %s [%s] %s (CVSS: %.1f)\n",
					severityColor, vuln.Severity, vuln.Name, vuln.CVSS)
				fmt.Printf("    â””â”€ %s\n", vuln.Description)
				if vuln.CVE != "æ— " && vuln.CVE != "" {
					fmt.Printf("    â””â”€ CVE: %s\n", vuln.CVE)
				}
				fmt.Printf("    â””â”€ è¯æ®: %s\n", evidence)
			}
		}

		if !vulnFound {
			fmt.Println("  â””â”€ æœªæ£€æµ‹åˆ°å·²çŸ¥æ¼æ´")
		}
	}

	// æ‰“å°æ¼æ´ç»Ÿè®¡ä¿¡æ¯
	fmt.Println("\næ¼æ´ç»Ÿè®¡:")
	fmt.Printf("æ€»è®¡å‘ç° %d ä¸ªæ½œåœ¨æ¼æ´:\n", len(detectedVulns))
	fmt.Printf("  - é«˜å±: %d\n", severityCounts["é«˜"])
	fmt.Printf("  - ä¸­å±: %d\n", severityCounts["ä¸­"])
	fmt.Printf("  - ä½å±: %d\n", severityCounts["ä½"])
}

// æ ¼å¼åŒ–æœåŠ¡ä¿¡æ¯æ˜¾ç¤º
func formatServiceInfo(result scanner.ScanResult) string {
	if result.Service == nil {
		return "æœªçŸ¥æœåŠ¡"
	}

	info := result.Service.Name
	if result.Service.Version != "" {
		info += " " + result.Service.Version
	}

	if result.Banner != "" {
		shortBanner := result.Banner
		if len(shortBanner) > 50 {
			shortBanner = shortBanner[:47] + "..."
		}
		info += " [" + shortBanner + "]"
	}

	return info
}

// æ ¹æ®ç«¯å£å·çŒœæµ‹æœåŠ¡ç±»å‹
func guessServiceByPort(port int) string {
	switch port {
	case 21:
		return "ftp"
	case 22:
		return "ssh"
	case 23:
		return "telnet"
	case 25, 465, 587:
		return "smtp"
	case 53:
		return "dns"
	case 80, 8080:
		return "http"
	case 443, 8443:
		return "http" // ä½¿ç”¨httpç›¸åŒçš„æ¼æ´åº“
	case 110, 995:
		return "pop3"
	case 143, 993:
		return "imap"
	case 161:
		return "snmp"
	default:
		return ""
	}
}

// æ£€æŸ¥ç‰¹å®šæœåŠ¡æ˜¯å¦å­˜åœ¨ç‰¹å®šæ¼æ´
func checkVulnerability(serviceType string, result *scanner.ScanResult, vuln *Vulnerability) (bool, string) {
	banner := result.Banner
	var version string

	if result.Service != nil {
		version = result.Service.Version
	}

	switch serviceType {
	case "ssh":
		// æ£€æŸ¥SSHç‰ˆæœ¬
		if vuln.Name == "OpenSSH < 7.4ç‰ˆæœ¬" && strings.Contains(version, "OpenSSH") {
			parts := strings.Split(version, " ")
			if len(parts) > 1 {
				versionStr := parts[1]
				if strings.HasPrefix(versionStr, "1.") ||
					strings.HasPrefix(versionStr, "2.") ||
					strings.HasPrefix(versionStr, "3.") ||
					strings.HasPrefix(versionStr, "4.") ||
					strings.HasPrefix(versionStr, "5.") ||
					strings.HasPrefix(versionStr, "6.") ||
					(strings.HasPrefix(versionStr, "7.") && versionStr < "7.4") {
					return true, fmt.Sprintf("æ£€æµ‹åˆ°ä½ç‰ˆæœ¬SSH: %s", version)
				}
			}
		}

		// æ£€æŸ¥SSHå¼±åŠ å¯†
		if vuln.Name == "SSHå¼±åŠ å¯†ç®—æ³•" && strings.Contains(banner, "3des") {
			return true, "æœåŠ¡å™¨æ”¯æŒå¼±åŠ å¯†ç®—æ³•: 3DES"
		}

	case "http":
		// æ£€æŸ¥ä¿¡æ¯æ³„éœ²
		if vuln.Name == "WebæœåŠ¡å™¨ä¿¡æ¯æ³„éœ²" &&
			(strings.Contains(banner, "Apache/") ||
				strings.Contains(banner, "nginx/") ||
				strings.Contains(banner, "Microsoft-IIS/")) {
			return true, fmt.Sprintf("æœåŠ¡å™¨å¤´ä¿¡æ¯æ³„éœ²ç‰ˆæœ¬: %s", banner)
		}

		// ç®€åŒ–ç‰ˆçš„Heartbleedæ£€æµ‹
		if vuln.Name == "Heartbleedæ¼æ´" &&
			result.Service != nil &&
			strings.Contains(version, "OpenSSL 1.0.1") {
			versionChar := version[len("OpenSSL 1.0.1")]
			if versionChar >= 'a' && versionChar <= 'f' {
				return true, fmt.Sprintf("æ£€æµ‹åˆ°æ˜“å—Heartbleedå½±å“çš„OpenSSLç‰ˆæœ¬: %s", version)
			}
		}

	case "ftp":
		// æ£€æŸ¥åŒ¿åFTPè®¿é—®
		if vuln.Name == "åŒ¿åFTPè®¿é—®" &&
			(strings.Contains(banner, "anonymous") ||
				strings.Contains(banner, "login anonymous")) {
			return true, "FTPæœåŠ¡å™¨æ ‡å¿—è¡¨æ˜å¯èƒ½æ”¯æŒåŒ¿åè®¿é—®"
		}

		// FTPæ˜æ–‡ä¼ è¾“æ€»æ˜¯å­˜åœ¨çš„é—®é¢˜
		if vuln.Name == "æ˜æ–‡FTPä¼ è¾“" {
			return true, "æ ‡å‡†FTPåè®®ä½¿ç”¨æ˜æ–‡ä¼ è¾“æ•°æ®å’Œå‡­æ®"
		}

	case "telnet":
		// Telnetæ˜æ–‡ä¼ è¾“æ€»æ˜¯å­˜åœ¨çš„é—®é¢˜
		if vuln.Name == "Telnetæ˜æ–‡ä¼ è¾“" {
			return true, "æ£€æµ‹åˆ°TelnetæœåŠ¡ï¼Œé»˜è®¤ä½¿ç”¨æ˜æ–‡ä¼ è¾“æ•°æ®"
		}

	case "smtp":
		// ç®€å•æ£€æµ‹æ˜¯å¦å¯èƒ½å­˜åœ¨å¼€æ”¾ä¸­ç»§
		if vuln.Name == "å¼€æ”¾é‚®ä»¶ä¸­ç»§" &&
			!strings.Contains(banner, "Authentication") {
			return true, "SMTP Banneræœªæ˜ç¡®æŒ‡ç¤ºéœ€è¦è®¤è¯ï¼Œå¯èƒ½å­˜åœ¨ä¸­ç»§é£é™©"
		}

		// æ£€æµ‹VRFYå‘½ä»¤æ˜¯å¦å¯ç”¨
		if vuln.Name == "SMTP VRFYå‘½ä»¤å¯ç”¨" {
			// å®é™…ä¸­éœ€è¦å°è¯•VRFYå‘½ä»¤ï¼Œè¿™é‡Œä»…ç¤ºä¾‹
			return true, "SMTPæœåŠ¡é€šå¸¸é»˜è®¤å¯ç”¨VRFYå‘½ä»¤"
		}
	}

	// æœªæ£€æµ‹åˆ°æ¼æ´
	return false, ""
}

// é¢å¤–çš„å®‰å…¨æ€§æ£€æŸ¥
func performSecurityChecks(target string) {
	var wg sync.WaitGroup

	// å¸¸è§å®‰å…¨æ£€æŸ¥åˆ—è¡¨
	checks := []struct {
		name string
		fn   func(string, *sync.WaitGroup)
	}{
		{
			name: "å¼€æ”¾ç«¯å£èŒƒå›´æ£€æŸ¥",
			fn:   checkPortRange,
		},
		{
			name: "å¼±SSLé…ç½®æ£€æŸ¥",
			fn:   checkWeakSSL,
		},
		{
			name: "DNSé…ç½®æ£€æŸ¥",
			fn:   checkDNSConfig,
		},
	}

	// æ‰§è¡Œæ‰€æœ‰å®‰å…¨æ£€æŸ¥
	for _, check := range checks {
		wg.Add(1)
		go check.fn(target, &wg)
	}

	// ç­‰å¾…æ‰€æœ‰æ£€æŸ¥å®Œæˆ
	wg.Wait()
}

// æ£€æŸ¥æ˜¯å¦å­˜åœ¨è¿‡å¤šå¼€æ”¾ç«¯å£
func checkPortRange(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] æ‰§è¡Œå¼€æ”¾ç«¯å£èŒƒå›´æ£€æŸ¥...\n")

	// æ£€æŸ¥èŒƒå›´ç«¯å£
	highPorts := "32768-33000"

	scanOptions := &scanner.ScanOptions{
		Target:   target,
		Ports:    highPorts,
		ScanType: scanner.ScanTypeTCP,
		Timeout:  time.Second * 1,
		Workers:  100,
	}

	results, err := scanner.ExecuteScan(scanOptions)
	if err != nil {
		fmt.Printf("    â””â”€ æ£€æŸ¥å¤±è´¥: %v\n", err)
		return
	}

	openCount := 0
	for _, result := range results {
		if result.State == scanner.PortStateOpen {
			openCount++
		}
	}

	if openCount > 5 {
		fmt.Printf("    â””â”€ [âš ï¸ è­¦å‘Š] å‘ç°å¤§é‡é«˜ç«¯å£å¼€æ”¾ (%d ä¸ª)\n", openCount)
		fmt.Printf("    â””â”€ å¯èƒ½è¡¨æ˜å­˜åœ¨æœªæˆæƒçš„æœåŠ¡æˆ–åé—¨\n")
	} else {
		fmt.Printf("    â””â”€ æœªå‘ç°å¼‚å¸¸çš„é«˜ç«¯å£å¼€æ”¾æƒ…å†µ\n")
	}
}

// æ£€æŸ¥å¼±SSLé…ç½®
func checkWeakSSL(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] æ‰§è¡ŒSSL/TLSé…ç½®æ£€æŸ¥...\n")

	// è¿æ¥åˆ°ç›®æ ‡çš„HTTPSç«¯å£
	conn, err := net.DialTimeout("tcp", fmt.Sprintf("%s:443", target), time.Second*5)
	if err != nil {
		fmt.Printf("    â””â”€ æœªå‘ç°HTTPSæœåŠ¡æˆ–è¿æ¥å¤±è´¥: %v\n", err)
		return
	}
	defer conn.Close()

	// å®é™…é¡¹ç›®ä¸­éœ€è¦å¯¹SSLé…ç½®è¿›è¡Œæ·±å…¥æ£€æµ‹
	// è¿™é‡Œä»…åšç¤ºä¾‹
	fmt.Printf("    â””â”€ HTTPSæœåŠ¡å¯è®¿é—®ï¼Œä½†éœ€è¦ä¸“é—¨çš„SSLæµ‹è¯•å·¥å…·è¿›è¡Œæ·±å…¥åˆ†æ\n")
	fmt.Printf("    â””â”€ å»ºè®®ä½¿ç”¨ä¸“ä¸šå·¥å…·å¦‚SSLLabs, testssl.shç­‰è¿›è¡Œæ£€æµ‹\n")
}

// æ£€æŸ¥DNSé…ç½®
func checkDNSConfig(target string, wg *sync.WaitGroup) {
	defer wg.Done()

	fmt.Printf("[+] æ‰§è¡ŒDNSé…ç½®æ£€æŸ¥...\n")

	// æ£€æŸ¥æ˜¯å¦å­˜åœ¨åŒºåŸŸä¼ é€æ¼æ´
	// å®é™…å®ç°éœ€è¦å‘é€DNS AXFRè¯·æ±‚

	// è§£æç›®æ ‡ä¸»æœº
	ips, err := net.LookupIP(target)
	if err != nil {
		fmt.Printf("    â””â”€ æ— æ³•è§£æç›®æ ‡: %v\n", err)
		return
	}

	fmt.Printf("    â””â”€ ç›®æ ‡è§£æä¸º: %v\n", ips)
	fmt.Printf("    â””â”€ æœªæ‰§è¡Œå®Œæ•´DNSå®‰å…¨æ£€æµ‹ï¼Œå»ºè®®ä½¿ç”¨ä¸“ä¸šDNSå®‰å…¨å·¥å…·\n")
}

// è¿”å›ä¸ä¸¥é‡ç¨‹åº¦å¯¹åº”çš„é¢œè‰²ä»£ç 
func getSeverityColor(severity string) string {
	switch severity {
	case "é«˜":
		return "ğŸ”´"
	case "ä¸­":
		return "ğŸŸ "
	case "ä½":
		return "ğŸŸ¡"
	default:
		return "âšª"
	}
}
