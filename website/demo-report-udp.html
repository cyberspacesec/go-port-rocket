<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Go-Port-Rocket æ‰«ææŠ¥å‘Š</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.7.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/moment@2.29.1/moment.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #f5f5f5;
        }
        header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            text-align: center;
        }
        h1 {
            margin: 0;
            font-size: 24px;
        }
        .info-section {
            background-color: white;
            padding: 20px;
            border-radius: 5px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .info-item {
            margin-bottom: 10px;
        }
        .info-label {
            font-weight: bold;
            color: #2c3e50;
            display: inline-block;
            width: 120px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 20px;
        }
        th, td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }
        th {
            background-color: #2c3e50;
            color: white;
        }
        tr:nth-child(even) {
            background-color: #f2f2f2;
        }
        .open {
            color: #27ae60;
            font-weight: bold;
        }
        .closed {
            color: #e74c3c;
        }
        .filtered {
            color: #f39c12;
        }
        .banner {
            font-family: monospace;
            white-space: pre-wrap;
            background-color: #f9f9f9;
            padding: 8px;
            border-left: 3px solid #ddd;
            margin: 10px 0;
            font-size: 14px;
            overflow-x: auto;
        }
        .banner-explanation {
            color: #2c3e50;
            background-color: #fffde7;
            border-left: 3px solid #f1c40f;
            padding: 12px;
            margin-top: 8px;
            font-size: 14px;
            line-height: 1.5;
            border-radius: 4px;
        }
        .hex-data {
            color: #e74c3c;
            font-weight: bold;
        }
        .stats-section {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
        }
        .stat-box {
            flex: 1;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            text-align: center;
            margin: 0 10px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .stat-number {
            font-size: 24px;
            font-weight: bold;
            margin: 10px 0;
        }
        .open-stat .stat-number {
            color: #27ae60;
        }
        .closed-stat .stat-number {
            color: #e74c3c;
        }
        .filtered-stat .stat-number {
            color: #f39c12;
        }
        footer {
            text-align: center;
            margin-top: 30px;
            font-size: 12px;
            color: #7f8c8d;
        }
        /* ç«¯å£ç­›é€‰å™¨æ ·å¼ */
        .filter-container {
            display: flex;
            margin-bottom: 15px;
            align-items: center;
        }
        .filter-label {
            margin-right: 10px;
            font-weight: bold;
            color: #2c3e50;
        }
        .filter-btn {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 8px 12px;
            margin-right: 5px;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .filter-btn:hover {
            background-color: #e9e9e9;
        }
        .filter-btn.active {
            background-color: #2c3e50;
            color: white;
            border-color: #2c3e50;
        }
        .filter-btn.open-btn.active {
            background-color: #27ae60;
            border-color: #27ae60;
        }
        .filter-btn.closed-btn.active {
            background-color: #e74c3c;
            border-color: #e74c3c;
        }
        .filter-btn.filtered-btn.active {
            background-color: #f39c12;
            border-color: #f39c12;
        }
        .port-row {
            display: table-row;
        }
        .port-row.hidden {
            display: none;
        }
        .search-container {
            margin-left: auto;
        }
        .search-input {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        .error-section {
            border-left: 4px solid #e74c3c;
            background-color: #fdf7f7;
        }
        .warning-section {
            border-left: 4px solid #f39c12;
            background-color: #fef9e7;
        }
        .error-message, .warning-message {
            padding: 10px;
            line-height: 1.6;
        }
        .solution-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            margin: 15px 0;
        }
        .solution-box h3 {
            margin-top: 0;
            color: #2c3e50;
        }
        .solution-box ul {
            padding-left: 20px;
        }
        pre {
            background-color: #f1f1f1;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            margin: 5px 0;
            font-family: monospace;
        }
        .note {
            font-style: italic;
            color: #7f8c8d;
            font-size: 0.9em;
            margin-top: 15px;
        }
        /* æ•°æ®å¯è§†åŒ–æ ·å¼ */
        .charts-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            margin-bottom: 20px;
        }
        .chart-container {
            flex: 1;
            min-width: 300px;
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-title {
            font-size: 18px;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
            font-weight: bold;
        }
        .heatmap-container {
            width: 100%;
            overflow-x: auto;
            margin-top: 20px;
        }
        .port-cell {
            display: inline-block;
            width: 20px;
            height: 20px;
            margin: 1px;
            border-radius: 2px;
            text-align: center;
            font-size: 10px;
            line-height: 20px;
            color: white;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .port-cell:hover {
            transform: scale(1.2);
            z-index: 10;
        }
        .port-cell.open {
            background-color: #27ae60;
        }
        .port-cell.closed {
            background-color: #e74c3c;
        }
        .port-cell.filtered {
            background-color: #f39c12;
        }
        .port-legend {
            display: flex;
            justify-content: center;
            margin-top: 10px;
            gap: 15px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            font-size: 12px;
        }
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 2px;
            margin-right: 5px;
        }
        .timeline-controls {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-top: 15px;
            gap: 10px;
        }
        .scan-selector {
            padding: 5px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }
        .tab-container {
            margin-top: 20px;
        }
        .tabs {
            display: flex;
            border-bottom: 1px solid #ddd;
        }
        .tab {
            padding: 10px 15px;
            cursor: pointer;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-bottom: none;
            margin-right: 5px;
            border-radius: 4px 4px 0 0;
        }
        .tab.active {
            background-color: white;
            border-bottom: 1px solid white;
            margin-bottom: -1px;
            font-weight: bold;
        }
        .tab-content {
            display: none;
            padding: 15px;
            background-color: white;
            border: 1px solid #ddd;
            border-top: none;
        }
        .tab-content.active {
            display: block;
        }
        .tooltip-container {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            pointer-events: none;
            display: none;
        }
        
        /* åè®®è§£æå™¨æ ·å¼ */
        .protocol-analyzer {
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: hidden;
        }
        .analyzer-header {
            background-color: #2c3e50;
            color: white;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .analyzer-header h2 {
            margin: 0;
            font-size: 18px;
        }
        .tabs {
            display: flex;
        }
        .tab {
            padding: 8px 15px;
            background-color: rgba(255,255,255,0.1);
            cursor: pointer;
            margin-left: 5px;
            border-radius: 3px;
            transition: background-color 0.2s;
        }
        .tab.active {
            background-color: rgba(255,255,255,0.3);
            font-weight: bold;
        }
        .analyzer-content {
            display: none;
            padding: 15px;
        }
        .analyzer-content.active {
            display: block;
        }
        .protocol-fields {
            font-family: monospace;
        }
        .protocol-field {
            margin-bottom: 10px;
            padding: 10px;
            border-radius: 4px;
            background-color: #f8f9fa;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .protocol-field:hover {
            background-color: #eaecef;
        }
        .field-name {
            font-weight: bold;
            display: inline-block;
            width: 150px;
        }
        .field-value {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 3px;
            color: white;
            font-weight: bold;
        }
        .field-description {
            margin-top: 5px;
            color: #666;
            font-size: 13px;
            font-family: Arial, sans-serif;
        }
        .hex-tooltip {
            position: absolute;
            background-color: rgba(0,0,0,0.8);
            color: white;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            max-width: 300px;
            display: none;
            z-index: 1000;
        }
        /* åå…­è¿›åˆ¶æ•°æ®ä¸åŒç±»å‹çš„é¢œè‰² */
        .hex-type-header { background-color: #3498db; }
        .hex-type-data { background-color: #2ecc71; }
        .hex-type-timestamp { background-color: #9b59b6; }
        .hex-type-identifier { background-color: #f39c12; }
        .hex-type-payload { background-color: #e74c3c; }
        .hex-viewer {
            padding: 15px;
            font-family: monospace;
            overflow-x: auto;
            white-space: nowrap;
            position: relative;
            line-height: 2;
        }
        .hex-byte {
            display: inline-block;
            margin: 0 2px;
            padding: 2px 4px;
            border-radius: 3px;
            cursor: pointer;
            position: relative;
        }
        .hex-byte:hover {
            background-color: #f1f1f1;
        }
        .hex-field {
            border: 1px solid transparent;
            border-radius: 3px;
        }
        .field-header {
            background-color: #3498db;
            color: white;
        }
        .field-data {
            background-color: #2ecc71;
            color: white;
        }
        .field-checksum {
            background-color: #e74c3c;
            color: white;
        }
        .field-options {
            background-color: #f39c12;
            color: white;
        }
        .field-payload {
            background-color: #9b59b6;
            color: white;
        }
        .protocol-details {
            padding: 15px;
            border-top: 1px solid #eee;
        }
        .protocol-field {
            margin-bottom: 10px;
            padding: 8px;
            border-radius: 4px;
            transition: background-color 0.3s;
        }
        .protocol-field:hover {
            background-color: #f9f9f9;
        }
        .field-name {
            font-weight: bold;
            margin-right: 10px;
            color: #2c3e50;
        }
        .field-value {
            font-family: monospace;
            background-color: #f8f9fa;
            padding: 2px 5px;
            border-radius: 3px;
        }
        .field-description {
            margin-top: 5px;
            color: #7f8c8d;
            font-size: 13px;
        }
        .analyzer-tabs {
            display: flex;
            background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
        }
        .analyzer-tab {
            padding: 10px 15px;
            cursor: pointer;
            border-bottom: 2px solid transparent;
        }
        .analyzer-tab.active {
            border-bottom: 2px solid #3498db;
            color: #3498db;
            font-weight: bold;
        }
        .analyzer-content {
            display: none;
            padding: 15px;
        }
        .analyzer-content.active {
            display: block;
        }
        .hex-tooltip {
            position: absolute;
            background-color: rgba(44, 62, 80, 0.9);
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            z-index: 100;
            max-width: 300px;
            pointer-events: none;
            display: none;
            word-wrap: break-word;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }
        .protocol-accordion {
            border: 1px solid #ddd;
            border-radius: 4px;
            margin-bottom: 10px;
        }
        .accordion-header {
            padding: 10px 15px;
            background-color: #f8f9fa;
            cursor: pointer;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .accordion-content {
            padding: 15px;
            display: none;
        }
        .accordion-header.active {
            background-color: #e9ecef;
        }
        .accordion-header.active + .accordion-content {
            display: block;
        }
        .accordion-icon {
            transition: transform 0.3s;
        }
        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }
        .bytes-row {
            display: flex;
            margin-bottom: 8px;
        }
        .offset {
            width: 60px;
            color: #7f8c8d;
        }
        .hex-bytes {
            flex: 2;
        }
        .ascii-bytes {
            flex: 1;
            margin-left: 15px;
            color: #7f8c8d;
        }
        .ascii-byte {
            display: inline-block;
            width: 8px;
        }
        .field-highlight {
            background-color: #fffde7;
            transition: background-color 0.3s;
        }
    </style>
</head>
<body>
    <header>
        <h1>Go-Port-Rocket ç«¯å£æ‰«ææŠ¥å‘Š</h1>
    </header>

    <div class="info-section">
        <div class="info-item">
            <span class="info-label">æ‰«æç›®æ ‡:</span>
            <span>scanme.nmap.org</span>
        </div>
        <div class="info-item">
            <span class="info-label">æ‰«æç±»å‹:</span>
            <span>udp</span>
        </div>
        <div class="info-item">
            <span class="info-label">å¼€å§‹æ—¶é—´:</span>
            <span>2025-03-15 15:47:28</span>
        </div>
        <div class="info-item">
            <span class="info-label">ç»“æŸæ—¶é—´:</span>
            <span>2025-03-15 15:47:28</span>
        </div>
        <div class="info-item">
            <span class="info-label">æ‰«æè€—æ—¶:</span>
            <span>0.38 ç§’</span>
        </div>
    </div>
    <div class="info-section warning-section">
        <h2>â„¹ï¸ æ‰«ææƒé™æç¤º</h2>
        <div class="warning-message">
            <p>æ‚¨é€‰æ‹©çš„æ‰«æç±»å‹ <strong>udp</strong> é€šå¸¸éœ€è¦ç®¡ç†å‘˜/rootæƒé™æ‰èƒ½è·å¾—æœ€ä½³ç»“æœã€‚</p>
            <p>å¦‚æœæ‰«æç»“æœä¸å®Œæ•´æˆ–å‡ºç°ä»¥ä¸‹æƒ…å†µï¼Œè¯·è€ƒè™‘ä½¿ç”¨ç®¡ç†å‘˜æƒé™é‡æ–°è¿è¡Œæ‰«æï¼š</p>
            <ul>
                <li>ç¨‹åºå¼‚å¸¸é€€å‡ºï¼Œæ˜¾ç¤º "root privileges required" é”™è¯¯</li>
                <li>æ‰€æœ‰ç«¯å£éƒ½æ˜¾ç¤ºä¸ºè¿‡æ»¤çŠ¶æ€</li>
                <li>æ‰«æé€Ÿåº¦å¼‚å¸¸ç¼“æ…¢</li>
            </ul>
            <div class="solution-box">
                <h3>åœ¨æ²¡æœ‰ç®¡ç†å‘˜æƒé™çš„æƒ…å†µä¸‹è¿è¡Œæ‰«æ:</h3>
                <p>å¦‚æœæ— æ³•è·å–ç®¡ç†å‘˜æƒé™ï¼Œå»ºè®®ä½¿ç”¨TCPæ‰«æç±»å‹ä»£æ›¿:</p>
                <pre>go-port-rocket scan -t scanme.nmap.org -p ... -s tcp</pre>
            </div>
        </div>
    </div>
    <div class="info-section">
        <h2>ç«¯å£æ‰«æç»“æœ</h2>
        
        <div class="stats-section">
            <div class="stat-box open-stat">
                <div>å¼€æ”¾ç«¯å£</div>
                <div class="stat-number">1</div>
            </div>
            <div class="stat-box closed-stat">
                <div>å…³é—­ç«¯å£</div>
                <div class="stat-number">0</div>
            </div>
            <div class="stat-box filtered-stat">
                <div>è¿‡æ»¤ç«¯å£</div>
                <div class="stat-number">4</div>
            </div>
            <div class="stat-box">
                <div>æ€»è®¡ç«¯å£</div>
                <div class="stat-number">5</div>
            </div>
        </div>
        
        <div class="tab-container">
            <div class="tabs">
                <div class="tab active" onclick="switchTab('overview')">æ‰«ææ¦‚è§ˆ</div>
                <div class="tab" onclick="switchTab('distribution')">ç«¯å£åˆ†å¸ƒ</div>
                <div class="tab" onclick="switchTab('timeline')">æ—¶é—´è½´å¯¹æ¯”</div>
            </div>
            
            <div id="overview" class="tab-content active">
                <div class="charts-container">
                    <div class="chart-container">
                        <div class="chart-title">ç«¯å£çŠ¶æ€åˆ†å¸ƒ</div>
                        <canvas id="portStatusChart"></canvas>
                    </div>
                    <div class="chart-container">
                        <div class="chart-title">æœåŠ¡ç±»å‹åˆ†å¸ƒ</div>
                        <canvas id="serviceTypeChart"></canvas>
                    </div>
                </div>
            </div>
            
            <div id="distribution" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">ç«¯å£åˆ†å¸ƒçƒ­å›¾</div>
                    <div class="heatmap-container" id="portHeatmap"></div>
                    <div class="port-legend">
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #27ae60;"></div>
                            <span>å¼€æ”¾</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #e74c3c;"></div>
                            <span>å…³é—­</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background-color: #f39c12;"></div>
                            <span>è¿‡æ»¤</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div id="timeline" class="tab-content">
                <div class="chart-container">
                    <div class="chart-title">å†å²æ‰«æå¯¹æ¯”</div>
                    <p class="note" style="text-align:center;">ä¿å­˜æ­¤æŠ¥å‘Šåï¼Œæœªæ¥çš„æ‰«æå°†åœ¨æ­¤å¤„æ˜¾ç¤ºå†å²å¯¹æ¯”ã€‚</p>
                    <div class="timeline-controls">
                        <select class="scan-selector" id="scanSelector" disabled>
                            <option value="current">å½“å‰æ‰«æ - 2025-03-15 15:47:28</option>
                        </select>
                        <button class="filter-btn" disabled>åŠ è½½å¯¹æ¯”</button>
                    </div>
                    <canvas id="timelineChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="tooltip-container" id="portTooltip"></div>
        
        <div class="filter-container">
            <span class="filter-label">çŠ¶æ€ç­›é€‰:</span>
            <button class="filter-btn all-btn active" onclick="filterPorts('all')">å…¨éƒ¨</button>
            <button class="filter-btn open-btn" onclick="filterPorts('open')">å¼€æ”¾</button>
            <button class="filter-btn closed-btn" onclick="filterPorts('closed')">å…³é—­</button>
            <button class="filter-btn filtered-btn" onclick="filterPorts('filtered')">è¿‡æ»¤</button>
            
            <div class="search-container">
                <input type="text" class="search-input" id="portSearch" onkeyup="searchPort()" placeholder="æœç´¢ç«¯å£...">
            </div>
        </div>
        
        <table id="portTable">
            <thead>
                <tr>
                    <th>ç«¯å£</th>
                    <th>çŠ¶æ€</th>
                    <th>æœåŠ¡</th>
                    <th>ç‰ˆæœ¬</th>
                    <th>TTL</th>
                </tr>
            </thead>
            <tbody>                <tr class="port-row" data-state="filtered" data-port="5353">
                    <td>5353</td>
                    <td class="filtered">è¿‡æ»¤</td>
                    <td></td>
                    <td></td>
                    <td>0</td>
                </tr>                <tr class="port-row" data-state="filtered" data-port="161">
                    <td>161</td>
                    <td class="filtered">è¿‡æ»¤</td>
                    <td></td>
                    <td></td>
                    <td>0</td>
                </tr>                <tr class="port-row" data-state="filtered" data-port="53">
                    <td>53</td>
                    <td class="filtered">è¿‡æ»¤</td>
                    <td></td>
                    <td></td>
                    <td>0</td>
                </tr>                <tr class="port-row" data-state="filtered" data-port="1900">
                    <td>1900</td>
                    <td class="filtered">è¿‡æ»¤</td>
                    <td></td>
                    <td></td>
                    <td>0</td>
                </tr>                <tr class="port-row" data-state="open" data-port="123">
                    <td>123</td>
                    <td class="open">å¼€æ”¾</td>
                    <td>ntp</td>
                    <td></td>
                    <td>0</td>
                </tr>
                <tr class="port-row banner-row" data-state="open" data-port="123">
                    <td colspan="5">
                        <div class="banner"><span class="hex-data">240303e90000228500001a4e4c7ce64aeb7fabd6cab706110000000000000000eb7faf10ab996a9aeb7faf10aba76dbb</span></div>
                    <div class="banner-explanation">ğŸ” <strong>æ•°æ®è§£æ:</strong> è¿™æ˜¯NTPæœåŠ¡çš„åŸå§‹å“åº”æ•°æ®åŒ…ã€‚NTP(ç½‘ç»œæ—¶é—´åè®®)ç”¨äºæ—¶é—´åŒæ­¥ï¼Œå“åº”åŒ…å«ä»¥ä¸‹ä¿¡æ¯ï¼š<ul><li>å‰2å­—èŠ‚(LI, VN, Mode): åŒ…å«è®¤è¯å’Œæ¨¡å¼æ ‡è¯†</li><li>åç»­å­—èŠ‚: ç³»ç»Ÿæ—¶é—´æˆ³ã€å‚è€ƒæ—¶é—´æˆ³ã€ç²¾åº¦å’Œè½®è¯¢é—´éš”</li></ul>çº¢è‰²æ ‡è®°çš„åå…­è¿›åˆ¶æ•°æ®æ˜¯åŸå§‹æ•°æ®åŒ…å†…å®¹ã€‚</div>
                <div class="protocol-analyzer" id="analyzer-123">
                    <div class="analyzer-header">
                        <h2>NTP åè®®åˆ†æ (ç«¯å£ 123)</h2>
                        <div class="tabs">
                            <div class="tab active" data-tab="parsed-123">ç»“æ„åŒ–è§†å›¾</div>
                            <div class="tab" data-tab="raw-123">åŸå§‹æ•°æ®</div>
                        </div>
                    </div>
                    <div class="analyzer-content active" id="analyzer-123-parsed">
                        <div class="protocol-fields"></div>
                    </div>
                    <div class="analyzer-content" id="analyzer-%!d(string=240303e90000228500001a4e4c7ce64aeb7fabd6cab706110000000000000000eb7faf10ab996a9aeb7faf10aba76dbb)-raw">
                        <pre>%!s(int=123)</pre>
                    </div>
                </div>
                <div class="hex-tooltip" id="hex-tooltip-%!d(MISSING)"></div>
                    </td>
                </tr>
            </tbody>
        </table>
    </div>

    <footer>
        <p>æŠ¥å‘Šç”Ÿæˆæ—¶é—´: 2025-03-15 15:47:28 | Go-Port-Rocket ç«¯å£æ‰«æå·¥å…·</p>
    </footer>

    <script>
        // ç«¯å£ç­›é€‰åŠŸèƒ½
        function filterPorts(state) {
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            document.querySelectorAll('.filter-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector('.filter-btn.' + state + '-btn').classList.add('active');
            
            // ç­›é€‰è¡¨æ ¼è¡Œ
            const rows = document.querySelectorAll('.port-row');
            rows.forEach(row => {
                if (state === 'all') {
                    row.classList.remove('hidden');
                } else {
                    if (row.getAttribute('data-state') === state) {
                        row.classList.remove('hidden');
                    } else {
                        row.classList.add('hidden');
                    }
                }
            });
        }
        
        // ç«¯å£æœç´¢åŠŸèƒ½
        function searchPort() {
            const input = document.getElementById('portSearch');
            const filter = input.value.toUpperCase();
            const table = document.getElementById('portTable');
            const rows = table.getElementsByTagName('tr');
            
            // ä»ç´¢å¼•1å¼€å§‹è·³è¿‡è¡¨å¤´
            for (let i = 1; i < rows.length; i++) {
                const port = rows[i].getAttribute('data-port');
                if (port) {
                    if (port.includes(filter)) {
                        rows[i].style.display = "";
                    } else {
                        rows[i].style.display = "none";
                    }
                }
            }
        }
        
        // é€‰é¡¹å¡åˆ‡æ¢åŠŸèƒ½
        function switchTab(tabId) {
            // éšè—æ‰€æœ‰æ ‡ç­¾å†…å®¹
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // å–æ¶ˆæ‰€æœ‰æ ‡ç­¾æ¿€æ´»çŠ¶æ€
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾å’Œå†…å®¹
            document.getElementById(tabId).classList.add('active');
            document.querySelector('.tab[onclick="switchTab(\'' + tabId + '\')"]').classList.add('active');
        }
        
        // åˆå§‹åŒ–ç«¯å£çŠ¶æ€åˆ†å¸ƒå›¾è¡¨
        function initPortStatusChart() {
            const ctx = document.getElementById('portStatusChart').getContext('2d');
            
            const data = {
                labels: ['å¼€æ”¾', 'å…³é—­', 'è¿‡æ»¤'],
                datasets: [{
                    data: [1, 0, 4],
                    backgroundColor: ['#27ae60', '#e74c3c', '#f39c12'],
                    borderWidth: 0
                }]
            };
            
            new Chart(ctx, {
                type: 'pie',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    const label = context.label || '';
                                    const value = context.raw || 0;
                                    const total = context.chart.data.datasets[0].data.reduce((a, b) => a + b, 0);
                                    const percentage = Math.round((value / total) * 100);
                                    return label + ': ' + value + ' (' + percentage + '%!)(MISSING)';
                                }
                            }
                        }
                    }
                }
            });
        }
        
        // åˆå§‹åŒ–æœåŠ¡ç±»å‹åˆ†å¸ƒå›¾è¡¨
        function initServiceTypeChart() {
            const ctx = document.getElementById('serviceTypeChart').getContext('2d');
            
            // ä»è¡¨æ ¼ä¸­æå–æœåŠ¡ä¿¡æ¯
            const services = {};
            const rows = document.querySelectorAll('.port-row:not(.banner-row)');
            
            rows.forEach(row => {
                // ä»…ç»Ÿè®¡å¼€æ”¾ç«¯å£
                if (row.getAttribute('data-state') === 'open') {
                    const cells = row.getElementsByTagName('td');
                    if (cells.length >= 3) {
                        const service = cells[2].textContent.trim() || 'unknown';
                        services[service] = (services[service] || 0) + 1;
                    }
                }
            });
            
            const serviceLabels = Object.keys(services);
            const serviceData = Object.values(services);
            
            // ç”Ÿæˆé¢œè‰²
            const colors = generateColors(serviceLabels.length);
            
            const data = {
                labels: serviceLabels,
                datasets: [{
                    data: serviceData,
                    backgroundColor: colors,
                    borderWidth: 0
                }]
            };
            
            new Chart(ctx, {
                type: 'doughnut',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            display: serviceLabels.length > 0
                        }
                    }
                }
            });
        }
        
        // åˆå§‹åŒ–ç«¯å£åˆ†å¸ƒçƒ­å›¾
        function initPortHeatmap() {
            const container = document.getElementById('portHeatmap');
            const tooltip = document.getElementById('portTooltip');
            
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            // è·å–ç«¯å£æ•°æ®
            const portData = [];
            const rows = document.querySelectorAll('.port-row:not(.banner-row)');
            
            rows.forEach(row => {
                const port = parseInt(row.getAttribute('data-port'));
                const state = row.getAttribute('data-state');
                if (!isNaN(port) && state) {
                    portData.push({ port, state });
                }
            });
            
            // å¦‚æœæ²¡æœ‰ç«¯å£æ•°æ®ï¼Œæ˜¾ç¤ºæç¤ºä¿¡æ¯
            if (portData.length === 0) {
                container.innerHTML = '<p style="text-align:center;color:#7f8c8d;">æ²¡æœ‰å¯ç”¨çš„ç«¯å£æ•°æ®</p>';
                return;
            }
            
            // åˆ›å»ºçƒ­å›¾å•å…ƒæ ¼
            portData.forEach(data => {
                const cell = document.createElement('div');
                cell.className = 'port-cell ' + data.state;
                cell.setAttribute('data-port', data.port);
                cell.textContent = '';
                
                // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶
                cell.addEventListener('mouseover', (e) => {
                    const rect = e.target.getBoundingClientRect();
                    tooltip.style.left = rect.left + window.scrollX + 'px';
                    tooltip.style.top = (rect.top - 30) + window.scrollY + 'px';
                    tooltip.textContent = 'ç«¯å£ ' + data.port + ': ' + getStateText(data.state);
                    tooltip.style.display = 'block';
                });
                
                cell.addEventListener('mouseout', () => {
                    tooltip.style.display = 'none';
                });
                
                // ç‚¹å‡»è·³è½¬åˆ°è¡¨æ ¼å¯¹åº”è¡Œ
                cell.addEventListener('click', () => {
                    const targetRow = document.querySelector('.port-row[data-port="' + data.port + '"]:not(.banner-row)');
                    if (targetRow) {
                        targetRow.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        // é«˜äº®æ˜¾ç¤º
                        targetRow.style.backgroundColor = '#fffde7';
                        setTimeout(() => {
                            targetRow.style.backgroundColor = '';
                        }, 2000);
                    }
                });
                
                container.appendChild(cell);
            });
        }
        
        // è·å–çŠ¶æ€æ–‡æœ¬
        function getStateText(state) {
            switch(state) {
                case 'open': return 'å¼€æ”¾';
                case 'closed': return 'å…³é—­';
                case 'filtered': return 'è¿‡æ»¤';
                default: return 'æœªçŸ¥';
            }
        }
        
        // ç”Ÿæˆé¢œè‰²æ•°ç»„
        function generateColors(count) {
            const baseColors = [
                '#3498db', '#9b59b6', '#1abc9c', '#34495e', '#f1c40f', 
                '#e67e22', '#e74c3c', '#2ecc71', '#16a085', '#27ae60',
                '#2980b9', '#8e44ad', '#f39c12', '#d35400', '#c0392b'
            ];
            
            // å¦‚æœåŸºç¡€é¢œè‰²è¶³å¤Ÿï¼Œç›´æ¥è¿”å›
            if (count <= baseColors.length) {
                return baseColors.slice(0, count);
            }
            
            // å¦åˆ™ç”Ÿæˆæ›´å¤šé¢œè‰²
            const colors = [...baseColors];
            while (colors.length < count) {
                const r = Math.floor(Math.random() * 200) + 50;
                const g = Math.floor(Math.random() * 200) + 50;
                const b = Math.floor(Math.random() * 200) + 50;
                colors.push('rgb(' + r + ', ' + g + ', ' + b + ')');
            }
            
            return colors;
        }
        
        // åˆå§‹åŒ–å†å²æ‰«ææ—¶é—´è½´
        function initTimelineChart() {
            const ctx = document.getElementById('timelineChart').getContext('2d');
            
            // æ²¡æœ‰å†å²æ•°æ®æ—¶æ˜¾ç¤ºæç¤ºä¿¡æ¯
            const data = {
                labels: ['å½“å‰æ‰«æ'],
                datasets: [{
                    label: 'å¼€æ”¾ç«¯å£',
                    data: [1],
                    backgroundColor: '#27ae60',
                    borderColor: '#27ae60',
                    borderWidth: 2,
                    tension: 0.1
                }, {
                    label: 'å…³é—­ç«¯å£',
                    data: [0],
                    backgroundColor: '#e74c3c',
                    borderColor: '#e74c3c',
                    borderWidth: 2,
                    tension: 0.1
                }, {
                    label: 'è¿‡æ»¤ç«¯å£',
                    data: [4],
                    backgroundColor: '#f39c12',
                    borderColor: '#f39c12',
                    borderWidth: 2,
                    tension: 0.1
                }]
            };
            
            new Chart(ctx, {
                type: 'line',
                data: data,
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    plugins: {
                        legend: {
                            position: 'bottom'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'ç«¯å£æ•°é‡'
                            }
                        }
                    }
                }
            });
        }
        
        // åè®®è§£æå™¨ç›¸å…³å‡½æ•°
        function switchAnalyzerTab(portId, tabName) {
            // å–æ¶ˆæ‰€æœ‰æ ‡ç­¾æ¿€æ´»çŠ¶æ€
            document.querySelectorAll('#analyzer-' + portId + ' .analyzer-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // éšè—æ‰€æœ‰å†…å®¹
            document.querySelectorAll('#analyzer-' + portId + ' .analyzer-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // æ¿€æ´»é€‰ä¸­çš„æ ‡ç­¾å’Œå†…å®¹
            document.querySelector('#analyzer-' + portId + ' .analyzer-tab[onclick="switchAnalyzerTab(' + portId + ', \'' + tabName + '\')"]').classList.add('active');
            document.getElementById('analyzer-' + portId + '-' + tabName).classList.add('active');
        }
        
        // åˆå§‹åŒ–åå…­è¿›åˆ¶æŸ¥çœ‹å™¨
        function initHexViewer(portId, hexData) {
            const container = document.getElementById('hex-viewer-' + portId);
            const tooltip = document.getElementById('hex-tooltip-' + portId);
            
            if (!container || !hexData) return;
            
            // ç¡®ä¿hexDataæ˜¯å¶æ•°é•¿åº¦ï¼ˆæ¯ä¸ªå­—èŠ‚ä¸¤ä¸ªåå…­è¿›åˆ¶å­—ç¬¦ï¼‰
            if (hexData.length %! (MISSING)!== 0) {
                hexData = '0' + hexData;
            }
            
            // æ¸…ç©ºå®¹å™¨
            container.innerHTML = '';
            
            // æ¯è¡Œæ˜¾ç¤º16ä¸ªå­—èŠ‚
            const bytesPerRow = 16;
            const rows = Math.ceil(hexData.length / 2 / bytesPerRow);
            
            for (let i = 0; i < rows; i++) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'bytes-row';
                
                // æ·»åŠ åç§»é‡
                const offsetDiv = document.createElement('div');
                offsetDiv.className = 'offset';
                offsetDiv.textContent = (i * bytesPerRow).toString(16).padStart(4, '0') + ':';
                rowDiv.appendChild(offsetDiv);
                
                // æ·»åŠ åå…­è¿›åˆ¶éƒ¨åˆ†
                const hexDiv = document.createElement('div');
                hexDiv.className = 'hex-bytes';
                
                // æ·»åŠ ASCIIéƒ¨åˆ†
                const asciiDiv = document.createElement('div');
                asciiDiv.className = 'ascii-bytes';
                
                for (let j = 0; j < bytesPerRow; j++) {
                    const byteIndex = i * bytesPerRow + j;
                    if (byteIndex * 2 >= hexData.length) break;
                    
                    const byteValue = hexData.substr(byteIndex * 2, 2);
                    
                    // åˆ›å»ºåå…­è¿›åˆ¶å­—èŠ‚å…ƒç´ 
                    const hexByte = document.createElement('span');
                    hexByte.className = 'hex-byte';
                    hexByte.textContent = byteValue;
                    hexByte.setAttribute('data-offset', byteIndex);
                    hexByte.setAttribute('data-value', byteValue);
                    
                    // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶
                    hexByte.addEventListener('mouseover', (e) => {
                        const byte = e.target;
                        const rect = byte.getBoundingClientRect();
                        const offset = byte.getAttribute('data-offset');
                        const value = byte.getAttribute('data-value');
                        
                        tooltip.style.left = (rect.left + window.scrollX) + 'px';
                        tooltip.style.top = (rect.top - 30 + window.scrollY) + 'px';
                        tooltip.innerHTML = 'åç§»é‡: 0x' + parseInt(offset).toString(16) + '<br>å€¼: 0x' + value + ' (' + parseInt(value, 16) + ')';
                        tooltip.style.display = 'block';
                    });
                    
                    hexByte.addEventListener('mouseout', () => {
                        tooltip.style.display = 'none';
                    });
                    
                    hexDiv.appendChild(hexByte);
                    
                    // æ·»åŠ ASCIIå­—ç¬¦
                    const charCode = parseInt(byteValue, 16);
                    const asciiChar = (charCode >= 32 && charCode <= 126) ? String.fromCharCode(charCode) : '.';
                    
                    const asciiByte = document.createElement('span');
                    asciiByte.className = 'ascii-byte';
                    asciiByte.textContent = asciiChar;
                    asciiDiv.appendChild(asciiByte);
                }
                
                rowDiv.appendChild(hexDiv);
                rowDiv.appendChild(asciiDiv);
                container.appendChild(rowDiv);
            }
            
            // æ ¹æ®åè®®ç±»å‹åº”ç”¨å­—æ®µé«˜äº®
            const serviceName = document.querySelector('#analyzer-' + portId + ' .protocol-title').textContent.split(' ')[0].toLowerCase();
            applyProtocolHighlighting(portId, serviceName, hexData);
        }
        
        // åº”ç”¨åè®®å­—æ®µé«˜äº®
        function applyProtocolHighlighting(portId, protocol, hexData) {
            const hexViewer = document.getElementById('hex-viewer-' + portId);
            const detailsContainer = document.getElementById('protocol-details-' + portId);
            
            if (!hexViewer || !detailsContainer) return;
            
            // æ¸…ç©ºå­—æ®µå®¹å™¨
            detailsContainer.innerHTML = '';
            
            // æ ¹æ®ä¸åŒåè®®ç±»å‹å®šä¹‰å­—æ®µ
            let fields = [];
            
            switch (protocol.toLowerCase()) {
                case 'ntp':
                    fields = parseNTP(hexData);
                    break;
                case 'dns':
                    fields = parseDNS(hexData);
                    break;
                case 'snmp':
                    fields = parseSNMP(hexData);
                    break;
                default:
                    // é€šç”¨è§£æï¼Œä»…æ˜¾ç¤ºæ•°æ®å—
                    fields = [
                        { name: 'æ•°æ®', offset: 0, length: hexData.length / 2, type: 'payload', value: hexData, description: 'åŸå§‹åè®®æ•°æ®' }
                    ];
            }
            
            // ä¸ºæ¯ä¸ªå­—æ®µåˆ›å»ºè¯¦æƒ…åŒºåŸŸ
            fields.forEach((field, index) => {
                const fieldDiv = document.createElement('div');
                fieldDiv.className = 'protocol-field';
                fieldDiv.setAttribute('data-offset-start', field.offset);
                fieldDiv.setAttribute('data-offset-end', field.offset + field.length - 1);
                
                const fieldHTML = 
                    '<div>' +
                        '<span class="field-name">' + field.name + '</span>' +
                        '<span class="field-value" style="background-color: ' + getFieldColor(field.type) + '; color: white;">' + field.value + '</span>' +
                    '</div>' +
                    '<div class="field-description">' + field.description + '</div>';
                
                fieldDiv.innerHTML = fieldHTML;
                
                // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶ï¼Œé«˜äº®ç›¸åº”çš„åå…­è¿›åˆ¶å­—èŠ‚
                fieldDiv.addEventListener('mouseover', () => {
                    const startOffset = parseInt(fieldDiv.getAttribute('data-offset-start'));
                    const endOffset = parseInt(fieldDiv.getAttribute('data-offset-end'));
                    
                    // é«˜äº®ç›¸åº”çš„åå…­è¿›åˆ¶å­—èŠ‚
                    const hexBytes = hexViewer.querySelectorAll('.hex-byte');
                    hexBytes.forEach(byte => {
                        const offset = parseInt(byte.getAttribute('data-offset'));
                        if (offset >= startOffset && offset <= endOffset) {
                            byte.style.backgroundColor = getFieldColor(field.type);
                            byte.style.color = 'white';
                        }
                    });
                });
                
                fieldDiv.addEventListener('mouseout', () => {
                    // ç§»é™¤é«˜äº®
                    const hexBytes = hexViewer.querySelectorAll('.hex-byte');
                    hexBytes.forEach(byte => {
                        byte.style.backgroundColor = '';
                        byte.style.color = '';
                    });
                });
                
                detailsContainer.appendChild(fieldDiv);
            });
            
            // åˆå§‹é«˜äº®å­—æ®µï¼Œè¿™é‡Œæˆ‘ä»¬å¯ä»¥å°†é»˜è®¤çš„é¢œè‰²åº”ç”¨åˆ°åå…­è¿›åˆ¶æŸ¥çœ‹å™¨ä¸­
            fields.forEach(field => {
                const startOffset = field.offset;
                const endOffset = field.offset + field.length - 1;
                
                // æ·»åŠ å­—æ®µç±»
                const hexBytes = hexViewer.querySelectorAll('.hex-byte');
                hexBytes.forEach(byte => {
                    const offset = parseInt(byte.getAttribute('data-offset'));
                    if (offset >= startOffset && offset <= endOffset) {
                        byte.classList.add('hex-field');
                        byte.classList.add('field-' + field.type);
                    }
                });
            });
        }
        
        // è·å–å­—æ®µé¢œè‰²
        function getFieldColor(type) {
            switch(type) {
                case 'header': return '#3498db';   // è“è‰²
                case 'data': return '#2ecc71';     // ç»¿è‰²
                case 'timestamp': return '#9b59b6'; // ç´«è‰²
                case 'identifier': return '#f39c12'; // æ©™è‰²
                case 'payload': return '#e74c3c';  // çº¢è‰²
                default: return '#7f8c8d';         // ç°è‰²
            }
        }
        
        // è§£æNTPåè®®
        function parseNTP(hexData) {
            // NTPåŒ…ç»“æ„è§£æ
            if (hexData.length < 8) return [];
            
            // è·å–ç¬¬ä¸€ä¸ªå­—èŠ‚çš„äºŒè¿›åˆ¶è¡¨ç¤ºï¼Œç”¨äºè§£æå„ä¸ªæ ‡å¿—ä½
            const firstByte = parseInt(hexData.substr(0, 2), 16);
            const leapIndicator = (firstByte >> 6) & 0x03;
            const version = (firstByte >> 3) & 0x07;
            const mode = firstByte & 0x07;
            
            // è·å–NTPæ¨¡å¼çš„æ–‡æœ¬æè¿°
            let modeText;
            switch(mode) {
                case 1: modeText = "æ´»è·ƒå¯¹ç­‰ä½“"; break;
                case 2: modeText = "è¢«åŠ¨å¯¹ç­‰ä½“"; break;
                case 3: modeText = "å®¢æˆ·ç«¯"; break;
                case 4: modeText = "æœåŠ¡å™¨"; break;
                case 5: modeText = "å¹¿æ’­"; break;
                case 6: modeText = "NTPæ§åˆ¶æ¶ˆæ¯"; break;
                case 7: modeText = "é¢„ç•™ï¼ˆå†…éƒ¨ä½¿ç”¨ï¼‰"; break;
                default: modeText = "æœªå®šä¹‰"; break;
            }
            
            // è·å–é—°ç§’æŒ‡ç¤ºå™¨çš„æ–‡æœ¬æè¿°
            let leapText;
            switch(leapIndicator) {
                case 0: leapText = "æ— è­¦å‘Š"; break;
                case 1: leapText = "æœ€åä¸€åˆ†é’Ÿæœ‰61ç§’"; break;
                case 2: leapText = "æœ€åä¸€åˆ†é’Ÿæœ‰59ç§’"; break;
                case 3: leapText = "è­¦å‘Šï¼ˆæ—¶é’ŸæœªåŒæ­¥ï¼‰"; break;
            }
            
            const fields = [
                {
                    offset: 0,
                    length: 1,
                    name: "LI, VN, Mode",
                    value: hexData.substr(0, 2),
                    type: "header",
                    description: "é—°ç§’æŒ‡ç¤ºå™¨: " + leapIndicator + " (" + leapText + "), ç‰ˆæœ¬: " + version + ", æ¨¡å¼: " + mode + " (" + modeText + ")"
                },
                {
                    offset: 1,
                    length: 1,
                    name: "Stratum",
                    value: hexData.substr(2, 2),
                    type: "header",
                    description: "å±‚çº§: " + parseInt(hexData.substr(2, 2), 16) + " (" + getStratumDescription(parseInt(hexData.substr(2, 2), 16)) + ")"
                },
                {
                    offset: 2,
                    length: 1,
                    name: "Poll",
                    value: hexData.substr(4, 2),
                    type: "header",
                    description: "è½®è¯¢é—´éš”: " + Math.pow(2, parseInt(hexData.substr(4, 2), 16)) + " ç§’"
                },
                {
                    offset: 3,
                    length: 1,
                    name: "Precision",
                    value: hexData.substr(6, 2),
                    type: "header",
                    description: "ç²¾åº¦: " + Math.pow(2, parseInt(hexData.substr(6, 2), 16)) + " ç§’"
                },
                {
                    offset: 4,
                    length: 4,
                    name: "Root Delay",
                    value: hexData.substr(8, 8),
                    type: "data",
                    description: "æ ¹å»¶è¿Ÿ: " + parseInt(hexData.substr(8, 8), 16) / 65536 + " ç§’"
                },
                {
                    offset: 8,
                    length: 4,
                    name: "Root Dispersion",
                    value: hexData.substr(16, 8),
                    type: "data",
                    description: "æ ¹ç¦»æ•£åº¦: " + parseInt(hexData.substr(16, 8), 16) / 65536 + " ç§’"
                },
                {
                    offset: 12,
                    length: 4,
                    name: "Reference ID",
                    value: hexData.substr(24, 8),
                    type: "identifier",
                    description: "å‚è€ƒæ ‡è¯†ç¬¦: " + getRefIdText(hexData.substr(24, 8))
                }
            ];
            
            // æ·»åŠ å„ç§æ—¶é—´æˆ³
            if (hexData.length >= 48) {
                fields.push({
                    offset: 16,
                    length: 8,
                    name: "Reference Timestamp",
                    value: hexData.substr(32, 16),
                    type: "data",
                    description: "å‚è€ƒæ—¶é—´æˆ³: " + getNtpTimestamp(hexData.substr(32, 16))
                });
            }
            
            if (hexData.length >= 56) {
                fields.push({
                    offset: 24,
                    length: 8,
                    name: "Origin Timestamp",
                    value: hexData.substr(48, 16),
                    type: "data",
                    description: "èµ·å§‹æ—¶é—´æˆ³: " + getNtpTimestamp(hexData.substr(48, 16))
                });
            }
            
            if (hexData.length >= 64) {
                fields.push({
                    offset: 32,
                    length: 8,
                    name: "Receive Timestamp",
                    value: hexData.substr(64, 16),
                    type: "data",
                    description: "æ¥æ”¶æ—¶é—´æˆ³: " + getNtpTimestamp(hexData.substr(64, 16))
                });
            }
            
            if (hexData.length >= 72) {
                fields.push({
                    offset: 40,
                    length: 8,
                    name: "Transmit Timestamp",
                    value: hexData.substr(80, 16),
                    type: "data",
                    description: "å‘é€æ—¶é—´æˆ³: " + getNtpTimestamp(hexData.substr(80, 16))
                });
            }
            
            return fields;
        }
        
        // è·å–NTPåˆ†å±‚æè¿°
        function getStratumDescription(stratum) {
            if (stratum === 0) return "æœªæŒ‡å®šæˆ–æ— æ•ˆ";
            if (stratum === 1) return "ä¸»å‚è€ƒæºï¼ˆåŸå­é’Ÿã€GPSç­‰ï¼‰";
            if (stratum >= 2 && stratum <= 15) return "æ¬¡çº§å‚è€ƒæºï¼ˆé€šè¿‡NTPåŒæ­¥ï¼‰";
            return "æœªä½¿ç”¨";
        }
        
        // è·å–å‚è€ƒæ ‡è¯†ç¬¦çš„æ–‡æœ¬è¡¨ç¤º
        function getRefIdText(hexRefId) {
            if (hexRefId === "00000000") return "æœªæŒ‡å®š";
            
            // å°è¯•å°†å…¶ä½œä¸ºASCIIå­—ç¬¦è§£é‡Š
            let refText = "";
            for (let i = 0; i < 8; i += 2) {
                const charCode = parseInt(hexRefId.substr(i, 2), 16);
                if (charCode >= 32 && charCode <= 126) { // å¯æ‰“å°ASCII
                    refText += String.fromCharCode(charCode);
                }
            }
            
            // å¦‚æœèƒ½è§£æä¸ºæœ‰æ•ˆæ–‡æœ¬ï¼Œè¿”å›æ–‡æœ¬å½¢å¼
            if (refText.length > 0 && refText.trim().length > 0) {
                return hexRefId + " ('" + refText + "')";
            }
            
            // å¦åˆ™è¿”å›åŸå§‹åå…­è¿›åˆ¶
            return hexRefId;
        }
        
        // è§£æNTPæ—¶é—´æˆ³ï¼ˆä»1900å¹´1æœˆ1æ—¥å¼€å§‹çš„ç§’æ•°ï¼‰
        function getNtpTimestamp(hexTimestamp) {
            if (hexTimestamp.length < 16) return "æ— æ•ˆæ—¶é—´æˆ³";
            
            // NTPæ—¶é—´æˆ³çš„å‰32ä½æ˜¯ä»1900å¹´1æœˆ1æ—¥è‡³ä»Šçš„ç§’æ•°
            const seconds = parseInt(hexTimestamp.substr(0, 8), 16);
            
            // å32ä½æ˜¯ç§’çš„å°æ•°éƒ¨åˆ†
            const fraction = parseInt(hexTimestamp.substr(8, 8), 16) / Math.pow(2, 32);
            
            // è®¡ç®—è‡ª1900å¹´1æœˆ1æ—¥ä»¥æ¥çš„æ€»ç§’æ•°
            const totalSeconds = seconds + fraction;
            
            // 1900å¹´1æœˆ1æ—¥åˆ°1970å¹´1æœˆ1æ—¥ï¼ˆUnixæ—¶é—´æˆ³èµ·ç‚¹ï¼‰çš„ç§’æ•°
            const offsetToUnixEpoch = 2208988800;
            
            // è½¬æ¢ä¸ºUnixæ—¶é—´æˆ³
            const unixTimestamp = (totalSeconds - offsetToUnixEpoch) * 1000;
            
            // åˆ›å»ºDateå¯¹è±¡å¹¶æ ¼å¼åŒ–
            try {
                const date = new Date(unixTimestamp);
                return date.toISOString().replace('T', ' ').replace('Z', '') + " UTC";
            } catch (e) {
                return "è§£æé”™è¯¯ (" + hexTimestamp + ")";
            }
        }
        
        // è§£æDNSåè®®
        function parseDNS(hexData) {
            if (hexData.length < 24) return [];
            
            // æå–DNSå¤´éƒ¨çš„å„ä¸ªå­—æ®µ
            const transactionId = hexData.substr(0, 4);
            const flags = parseInt(hexData.substr(4, 4), 16);
            const qdcount = parseInt(hexData.substr(8, 4), 16); // é—®é¢˜è®°å½•æ•°
            const ancount = parseInt(hexData.substr(12, 4), 16); // å›ç­”è®°å½•æ•°
            const nscount = parseInt(hexData.substr(16, 4), 16); // æƒå¨åç§°æœåŠ¡å™¨è®°å½•æ•°
            const arcount = parseInt(hexData.substr(20, 4), 16); // é™„åŠ èµ„æºè®°å½•æ•°
            
            // è§£ææ ‡å¿—ä½
            const qr = (flags >> 15) & 0x01; // æŸ¥è¯¢/å“åº”æ ‡å¿—
            const opcode = (flags >> 11) & 0x0F; // æ“ä½œç 
            const aa = (flags >> 10) & 0x01; // æƒå¨å›ç­”
            const tc = (flags >> 9) & 0x01; // æˆªæ–­
            const rd = (flags >> 8) & 0x01; // æœŸæœ›é€’å½’
            const ra = (flags >> 7) & 0x01; // é€’å½’å¯ç”¨
            const z = (flags >> 4) & 0x07; // ä¿ç•™
            const rcode = flags & 0x0F; // å“åº”ç 
            
            // è·å–æ“ä½œç çš„æ–‡æœ¬æè¿°
            let opcodeText;
            switch(opcode) {
                case 0: opcodeText = "æ ‡å‡†æŸ¥è¯¢"; break;
                case 1: opcodeText = "åå‘æŸ¥è¯¢"; break;
                case 2: opcodeText = "æœåŠ¡å™¨çŠ¶æ€è¯·æ±‚"; break;
                default: opcodeText = "æœªçŸ¥(" + opcode + ")"; break;
            }
            
            // è·å–å“åº”ç çš„æ–‡æœ¬æè¿°
            let rcodeText;
            switch(rcode) {
                case 0: rcodeText = "æ— é”™è¯¯"; break;
                case 1: rcodeText = "æ ¼å¼é”™è¯¯"; break;
                case 2: rcodeText = "æœåŠ¡å™¨é”™è¯¯"; break;
                case 3: rcodeText = "åç§°é”™è¯¯"; break;
                case 4: rcodeText = "æœªå®ç°"; break;
                case 5: rcodeText = "æ‹’ç»"; break;
                default: rcodeText = "æœªçŸ¥(" + rcode + ")"; break;
            }
            
            // è§£ææŸ¥è¯¢éƒ¨åˆ†ï¼ˆå¦‚æœæœ‰ï¼‰
            let queryLen = 0;
            let queryName = "";
            
            if (qdcount > 0) {
                // DNSæŸ¥è¯¢åç§°ä½¿ç”¨ç‰¹æ®Šçš„å‹ç¼©æ ¼å¼
                let pos = 24; // æŸ¥è¯¢éƒ¨åˆ†å¼€å§‹çš„ä½ç½®ï¼ˆåå…­è¿›åˆ¶å­—ç¬¦ä½ç½®ï¼‰
                let labelLen = parseInt(hexData.substr(pos, 2), 16);
                
                while (labelLen > 0) {
                    pos += 2; // ç§»åˆ°æ ‡ç­¾å†…å®¹çš„å¼€å§‹ä½ç½®
                    
                    // æå–æ ‡ç­¾ï¼ˆåŸŸåçš„ä¸€éƒ¨åˆ†ï¼‰
                    let label = "";
                    for (let i = 0; i < labelLen; i++) {
                        const charCode = parseInt(hexData.substr(pos + i*2, 2), 16);
                        label += String.fromCharCode(charCode);
                    }
                    
                    queryName += label + ".";
                    pos += labelLen * 2; // ç§»åˆ°ä¸‹ä¸€ä¸ªé•¿åº¦å­—èŠ‚
                    
                    labelLen = parseInt(hexData.substr(pos, 2), 16);
                }
                
                // ç§»é™¤æœ«å°¾çš„ç‚¹å¹¶è®¡ç®—é•¿åº¦
                if (queryName.endsWith(".")) {
                    queryName = queryName.slice(0, -1);
                }
                
                queryLen = (pos + 2 - 24) / 2 + 4; // +4ç”¨äºç±»å‹å’Œç±»
            }
            
            // æ„å»ºDNSå­—æ®µæ•°ç»„
            const fields = [
                {
                    offset: 0,
                    length: 2,
                    name: "Transaction ID",
                    value: transactionId,
                    type: "header",
                    description: "äº¤æ˜“ID: 0x" + transactionId
                },
                {
                    offset: 2,
                    length: 2,
                    name: "Flags",
                    value: hexData.substr(4, 4),
                    type: "header",
                    description: "æ ‡å¿—: " + 
                                (qr === 1 ? "å“åº”" : "æŸ¥è¯¢") + ", " + 
                                "æ“ä½œç : " + opcodeText + ", " + 
                                (aa === 1 ? "æƒå¨åº”ç­”, " : "") + 
                                (tc === 1 ? "æˆªæ–­, " : "") + 
                                (rd === 1 ? "æœŸæœ›é€’å½’, " : "") + 
                                (ra === 1 ? "é€’å½’å¯ç”¨, " : "") + 
                                "å“åº”ç : " + rcodeText
                },
                {
                    offset: 4,
                    length: 2,
                    name: "Questions",
                    value: hexData.substr(8, 4),
                    type: "header",
                    description: "é—®é¢˜è®°å½•æ•°: " + qdcount
                },
                {
                    offset: 6,
                    length: 2,
                    name: "Answer RRs",
                    value: hexData.substr(12, 4),
                    type: "header",
                    description: "å›ç­”è®°å½•æ•°: " + ancount
                },
                {
                    offset: 8,
                    length: 2,
                    name: "Authority RRs",
                    value: hexData.substr(16, 4),
                    type: "header",
                    description: "æƒå¨åç§°æœåŠ¡å™¨è®°å½•æ•°: " + nscount
                },
                {
                    offset: 10,
                    length: 2,
                    name: "Additional RRs",
                    value: hexData.substr(20, 4),
                    type: "header",
                    description: "é™„åŠ èµ„æºè®°å½•æ•°: " + arcount
                }
            ];
            
            // æ·»åŠ æŸ¥è¯¢éƒ¨åˆ†ï¼ˆå¦‚æœæœ‰ï¼‰
            if (qdcount > 0) {
                fields.push({
                    offset: 12,
                    length: queryLen,
                    name: "Query",
                    value: hexData.substr(24, queryLen * 2),
                    type: "data",
                    description: "æŸ¥è¯¢åç§°: " + queryName
                });
                
                fields.push({
                    offset: 12 + queryLen,
                    length: hexData.length / 2 - (12 + queryLen),
                    name: "Records",
                    value: hexData.substr(24 + queryLen * 2),
                    type: "payload",
                    description: "åŒ…å«å›ç­”(" + ancount + "ä¸ª)ã€æƒå¨(" + nscount + "ä¸ª)å’Œé™„åŠ (" + arcount + "ä¸ª)èµ„æºè®°å½•"
                });
            }
            
            return fields;
        }
        
        // è§£æSNMPåè®®
        function parseSNMP(hexData) {
            if (hexData.length < 10) return [];
            
            // SNMPä½¿ç”¨ASN.1 BERç¼–ç 
            const fields = [];
            let offset = 0;
            
            // æ£€æŸ¥SNMPæ¶ˆæ¯å¼€å§‹(SEQUENCE)
            const sequenceType = hexData.substr(0, 2);
            const sequenceLenBytes = parseInt(hexData.substr(2, 2), 16);
            let sequenceLen = 0;
            
            if (sequenceType === "30") { // SEQUENCE
                if (sequenceLenBytes & 0x80) { // é•¿æ ¼å¼
                    const numLenBytes = sequenceLenBytes & 0x7F;
                    if (numLenBytes > 0 && hexData.length >= 4 + numLenBytes * 2) {
                        sequenceLen = parseInt(hexData.substr(4, numLenBytes * 2), 16);
                        offset = 2 + 2 + numLenBytes * 2;
                    }
                } else { // çŸ­æ ¼å¼
                    sequenceLen = sequenceLenBytes;
                    offset = 4;
                }
                
                fields.push({
                    offset: 0,
                    length: offset / 2,
                    name: "SNMP Message",
                    value: hexData.substr(0, offset),
                    type: "header",
                    description: "SNMPæ¶ˆæ¯å¼€å§‹ï¼Œæ€»é•¿åº¦: " + sequenceLen + " å­—èŠ‚"
                });
            }
            
            // å°è¯•è§£æç‰ˆæœ¬
            if (offset + 4 <= hexData.length) {
                const versionType = hexData.substr(offset, 2);
                const versionLen = parseInt(hexData.substr(offset + 2, 2), 16);
                
                if (versionType === "02" && versionLen === 1) { // INTEGERï¼Œé•¿åº¦ä¸º1
                    const version = parseInt(hexData.substr(offset + 4, 2), 16);
                    let versionText = "æœªçŸ¥";
                    
                    switch(version) {
                        case 0: versionText = "v1"; break;
                        case 1: versionText = "v2c"; break;
                        case 3: versionText = "v3"; break;
                    }
                    
                    fields.push({
                        offset: offset / 2,
                        length: 3,
                        name: "Version",
                        value: hexData.substr(offset, 6),
                        type: "data",
                        description: "SNMPç‰ˆæœ¬: " + versionText + " (" + version + ")"
                    });
                    
                    offset += 6;
                }
            }
            
            // å°è¯•è§£æç¤¾åŒºå­—ç¬¦ä¸²
            if (offset + 4 <= hexData.length) {
                const communityType = hexData.substr(offset, 2);
                const communityLen = parseInt(hexData.substr(offset + 2, 2), 16);
                
                if (communityType === "04" && offset + 4 + communityLen * 2 <= hexData.length) { // OCTET STRING
                    let communityStr = "";
                    for (let i = 0; i < communityLen; i++) {
                        const charCode = parseInt(hexData.substr(offset + 4 + i * 2, 2), 16);
                        communityStr += String.fromCharCode(charCode);
                    }
                    
                    fields.push({
                        offset: offset / 2,
                        length: 2 + communityLen,
                        name: "Community",
                        value: hexData.substr(offset, 4 + communityLen * 2),
                        type: "data",
                        description: "ç¤¾åŒºå­—ç¬¦ä¸²: '" + communityStr + "'"
                    });
                    
                    offset += 4 + communityLen * 2;
                }
            }
            
            // å¦‚æœè¿˜æœ‰å‰©ä½™æ•°æ®ï¼Œä½œä¸ºPDUæ·»åŠ 
            if (offset < hexData.length) {
                fields.push({
                    offset: offset / 2,
                    length: (hexData.length - offset) / 2,
                    name: "PDU",
                    value: hexData.substr(offset),
                    type: "payload",
                    description: "åè®®æ•°æ®å•å…ƒ"
                });
            }
            
            return fields;
        }

        // åœ¨é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–å›¾è¡¨
        document.addEventListener('DOMContentLoaded', function() {
            initPortStatusChart();
            initServiceTypeChart();
            initPortHeatmap();
            initTimelineChart();
            
            // åˆå§‹åŒ–æ‰€æœ‰åè®®è§£æå™¨
            document.querySelectorAll('.protocol-analyzer').forEach(analyzer => {
                const portId = analyzer.id.split('-')[1];
                const contentElement = document.getElementById('analyzer-' + portId + '-raw');
                if (contentElement) {
                    const hexData = contentElement.querySelector('pre').textContent;
                    if (hexData) {
                        initHexViewer(portId, hexData);
                    }
                }
            });
        });

        // åœ¨document.readyå¤„æ·»åŠ åˆå§‹åŒ–ä»£ç 
        document.addEventListener('DOMContentLoaded', function() {
            // æŸ¥æ‰¾æ‰€æœ‰çš„åè®®åˆ†æå™¨
            const analyzers = document.querySelectorAll('.protocol-analyzer');
            analyzers.forEach(analyzer => {
                // è·å–ç«¯å£å·å’Œåè®®ç±»å‹
                const id = analyzer.id.replace('analyzer-', '');
                const protocol = analyzer.querySelector('h2').textContent.split(' ')[0].toLowerCase();
                
                // è·å–åŸå§‹æ•°æ®
                const rawData = analyzer.querySelector('.analyzer-content[id$="-raw"] pre').textContent.trim();
                
                // ç§»é™¤éåå…­è¿›åˆ¶å­—ç¬¦
                const hexData = rawData.replace(/[^0-9A-Fa-f]/g, '');
                
                // è§£æåè®®æ•°æ®
                const fields = parseProtocolData(hexData, parseInt(id), protocol);
                
                // å¡«å……å­—æ®µå®¹å™¨
                const fieldsContainer = analyzer.querySelector('.protocol-fields');
                fields.forEach(field => {
                    const fieldDiv = document.createElement('div');
                    fieldDiv.className = 'protocol-field';
                    fieldDiv.setAttribute('data-offset-start', field.offset);
                    fieldDiv.setAttribute('data-offset-end', field.offset + field.length - 1);
                    
                    const fieldHTML = 
                        '<div>' +
                            '<span class="field-name">' + field.name + '</span>' +
                            '<span class="field-value" style="background-color: ' + getFieldColor(field.type) + '; color: white;">' + field.value + '</span>' +
                        '</div>' +
                        '<div class="field-description">' + field.description + '</div>';
                    
                    fieldDiv.innerHTML = fieldHTML;
                    fieldsContainer.appendChild(fieldDiv);
                    
                    // æ·»åŠ é¼ æ ‡æ‚¬åœäº‹ä»¶
                    fieldDiv.addEventListener('mouseover', function() {
                        const tooltip = document.getElementById('hex-tooltip-' + id);
                        tooltip.textContent = field.description;
                        tooltip.style.display = 'block';
                        tooltip.style.top = (event.pageY + 10) + 'px';
                        tooltip.style.left = (event.pageX + 10) + 'px';
                    });
                    
                    fieldDiv.addEventListener('mouseout', function() {
                        const tooltip = document.getElementById('hex-tooltip-' + id);
                        tooltip.style.display = 'none';
                    });
                });
                
                // è®¾ç½®æ ‡ç­¾åˆ‡æ¢
                const tabs = analyzer.querySelectorAll('.tab');
                tabs.forEach(tab => {
                    tab.addEventListener('click', function() {
                        // ç§»é™¤æ‰€æœ‰æ ‡ç­¾çš„æ´»åŠ¨çŠ¶æ€
                        analyzer.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                        // æ·»åŠ å½“å‰æ ‡ç­¾çš„æ´»åŠ¨çŠ¶æ€
                        this.classList.add('active');
                        
                        // éšè—æ‰€æœ‰å†…å®¹
                        analyzer.querySelectorAll('.analyzer-content').forEach(content => {
                            content.classList.remove('active');
                        });
                        
                        // æ˜¾ç¤ºå½“å‰æ ‡ç­¾å¯¹åº”çš„å†…å®¹
                        const tabId = this.getAttribute('data-tab');
                        document.getElementById('analyzer-' + id + '-' + tabId.split('-')[0]).classList.add('active');
                    });
                });
            });
        });

        // æ ¹æ®ç«¯å£å’Œåè®®è§£æåå…­è¿›åˆ¶æ•°æ®
        function parseProtocolData(hexData, port, protocol) {
            // å»æ‰ç©ºæ ¼ç­‰éåå…­è¿›åˆ¶å­—ç¬¦
            hexData = hexData.replace(/[^0-9A-Fa-f]/g, '');
            
            if (protocol.toLowerCase() === 'dns' || port === 53) {
                return parseDNS(hexData);
            } else if (protocol.toLowerCase() === 'ntp' || port === 123) {
                return parseNTP(hexData);
            } else if (protocol.toLowerCase() === 'snmp' || port === 161) {
                return parseSNMP(hexData);
            } else {
                // é€šç”¨åå…­è¿›åˆ¶æ•°æ®è§£æå™¨
                return parseGenericHex(hexData);
            }
        }

        // æ·»åŠ é€šç”¨åå…­è¿›åˆ¶æ•°æ®è§£æå™¨å‡½æ•°
        // é€šç”¨åå…­è¿›åˆ¶æ•°æ®è§£æå™¨
        function parseGenericHex(hexData) {
            const fields = [];
            const bytesPerRow = 16;
            
            // å¦‚æœæ•°æ®å¤ªé•¿ï¼Œåˆ†å—æ˜¾ç¤º
            for (let offset = 0; offset < hexData.length; offset += bytesPerRow * 2) {
                const remainingBytes = Math.min(bytesPerRow, (hexData.length - offset) / 2);
                const rowData = hexData.substr(offset, remainingBytes * 2);
                
                // åˆ›å»ºASCIIè¡¨ç¤º
                let asciiText = '';
                for (let i = 0; i < rowData.length; i += 2) {
                    const byte = parseInt(rowData.substr(i, 2), 16);
                    asciiText += (byte >= 32 && byte <= 126) ? String.fromCharCode(byte) : '.';
                }
                
                fields.push({
                    offset: offset / 2,
                    length: remainingBytes,
                    name: 'Offset ' + (offset/2).toString(16).padStart(4, '0'),
                    value: rowData,
                    type: 'data',
                    description: 'ASCII: ' + asciiText
                });
            }
            
            return fields;
        }
    </script>
</body>
</html>